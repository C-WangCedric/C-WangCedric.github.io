<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Raft论文解读</title>
    <link href="/2024/05/19/Raft%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/"/>
    <url>/2024/05/19/Raft%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Raft 是一种为了管理复制日志的一致性算法。它提供了和 Paxos 算法相同的功能和性能，但是它的算法结构和 Paxos 不同，使得 Raft 算法更加容易理解并且更容易构建实际的系统。为了提升可理解性，Raft 将一致性算法分解成了几个关键模块，例如领导人选举、日志复制和安全性。同时它通过实施一个更强的一致性来减少需要考虑的状态的数量。一项用户研究的结果表明，对于学生而言，Raft 算法比 Paxos 算法更加容易学习。Raft 算法还包括一个新的机制来允许集群成员的动态改变，它利用重叠的大多数来保证安全性。</p><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>一致性算法允许一组机器像一个整体一样工作，即使其中一些机器出现故障也能够继续工作下去。正因为如此，一致性算法在构建可信赖的大规模软件系统中扮演着重要的角色。在过去的 10 年里，Paxos 算法统治着一致性算法这一领域：绝大多数的实现都是基于 Paxos 或者受其影响。同时 Paxos 也成为了教学领域里讲解一致性问题时的示例。</p><p>但是不幸的是，尽管有很多工作都在尝试降低它的复杂性，但是 Paxos 算法依然十分难以理解。并且，Paxos 自身的算法结构需要进行大幅的修改才能够应用到实际的系统中。因此工业界和学术界都对 Paxos 算法感到十分头疼。</p><p>努力研究过 Paxos 算法之后，我们开始寻找一种新的一致性算法，可以为构建实际的系统和教学提供更好的基础。与 Paxos 不同，我们的首要目标是可理解性：我们是否可以在实际系统中定义一个一致性算法，并且比 Paxos 算法更容易学习。此外，我们希望该算法方便系统构建者的直觉的发展。重要的不仅仅是算法能够工作，更重要的是能够很清楚地知道它为什么能工作。</p><p>Raft 一致性算法就是这些工作的结果。在设计 Raft 算法的时候，我们使用一些特别的技巧来提升它的可理解性，包括算法分解（Raft 主要被分成了领导人选举，日志复制和安全三个模块）和减少状态机的状态（相对于 Paxos，Raft 减少了非确定性和服务器互相处于非一致性的方式）。一份针对两所大学 43 个学生的研究表明 Raft 明显比 Paxos 算法更加容易理解。在这些学生同时学习了这两种算法之后，和 Paxos 比起来，其中 33 个学生能够回答有关于 Raft 的问题。</p><p>Raft 算法在许多方面和现有的一致性算法都很相似（主要是 Oki 和 Liskov 的 Viewstamped Replication），但是它也有一些独特的特性：</p><ul><li><p><strong>强领导人</strong>：和其他一致性算法相比，Raft 使用一种更强的领导能力形式。比如，日志条目只从领导人发送给其他的服务器。这种方式简化了对复制日志的管理并且使得 Raft 算法更加易于理解。</p></li><li><p><strong>领导选举</strong>：Raft 算法使用一个随机计时器来选举领导人。这种方式只是在任何一致性算法都必须实现的心跳机制上增加了一点机制。在解决冲突的时候会更加简单快捷。</p></li><li><p><strong>成员关系调整</strong>：Raft 使用一种共同一致的方法来处理集群成员变换的问题，在这种方法下，处于调整过程中的两种不同的配置集群中大多数机器会有重叠，这就使得集群在成员变换的时候依然可以继续工作</p></li><li><ul><li>举个例子，假设有一个集群由三个节点组成：A、B和C。现在需要将节点D加入到集群中。在节点D加入之前，Raft算法会进行一次领导者选举，以确定哪个节点将成为新的领导者（包含D）。在选举过程中，大多数机器（在这个例子中是A、B和C）都同意将D添加到集群中。然后，新的领导者会向其他节点发送一条消息，通知它们要更新集群的配置。在这个过程中，节点D会被添加到集群中，<strong>而不需要重新配置整个集群</strong>。因此，Raft算法通过共识机制处理集群成员变换问题，使得集群在成员变化时仍然可以继续工作。</li><li>所以，简单来说，D节点在加入的过程中会参与领导者的选举，并且如果D成为了新的领导者，它会通知其他节点更新集群的配置。</li></ul></li></ul><p>我们相信，Raft 算法不论出于教学目的还是作为实践项目的基础都是要比 Paxos 或者其他一致性算法要优异的。它比其他算法更加简单，更加容易理解；它的算法描述足以实现一个现实的系统；它有好多开源的实现并且在很多公司里使用；它的安全特性已经被正式定义和证明；它的效率和其他算法比起来也不相上下。</p><p>接下来，这篇论文会介绍以下内容：复制状态机问题（第 2 节），讨论 Paxos 的优点和缺点（第 3 节），讨论我们为了可理解性而采取的方法（第 4 节），阐述 Raft 一致性算法（第 5-8 节），评价 Raft 算法（第 9 节），以及一些相关的工作（第 10 节）。</p><h2 id="2-复制状态机"><a href="#2-复制状态机" class="headerlink" title="2 复制状态机"></a>2 复制状态机</h2><p>一致性算法是从复制状态机的背景下提出的（参考英文原文引用37）</p><p>（一致性算法是在复制状态机的背景下提出的，它用于<strong>确保分布式系统中的多个服务器能够达到一致的状态</strong>。复制状态机是一种理论上的计算模型，它包含一组服务器，每台服务器上都运行着相同的状态机。这些状态机会执行相同的命令序列，并产生相同的输出结果。在分布式系统中，由于网络延迟、故障等因素，不同服务器可能会接收到不同的命令或者以不同的顺序接收到相同的命令，这就导致了状态不一致的问题。为了解决这个问题，<strong>一致性算法被设计出来</strong>，以确保所有服务器上的状态机即使在部分服务器宕机的情况下，也能够维护相同的状态。）</p><p>在这种方法中，一组服务器上的状态机产生相同状态的副本，并且在一些机器宕掉的情况下也可以继续运行。复制状态机在分布式系统中被用于解决很多容错的问题。例如，大规模的系统中通常都有一个集群领导人，像 GFS、HDFS 和 RAMCloud，典型应用就是一个独立的复制状态机去管理领导选举和存储配置信息并且在领导人宕机的情况下也要存活下来。比如 Chubby 和 ZooKeeper。</p><p><img src="https://github.com/maemual/raft-zh_cn/raw/master/images/raft-%E5%9B%BE1.png" alt="img"></p><p>图 1 ：复制状态机的结构。一致性算法管理着来自客户端指令的复制日志。状态机从日志中处理相同顺序的相同指令，所以产生的结果也是相同的。</p><p>复制状态机通常都是基于复制日志实现的，如图 1。每一个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。每一个日志都按照相同的顺序包含相同的指令，所以每一个服务器都执行相同的指令序列。因为每个状态机都是确定的，每一次执行操作都产生相同的状态和同样的序列。</p><p><strong>一致性算法的任务是保证复制日志的一致性。服务器上的一致性模块接收客户端发送的指令然后添加到自己的日志中。它和其他服务器上的一致性模块进行通信来保证每一个服务器上的日志最终都以相同的顺序包含相同的请求，即使有些服务器发生故障。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端</strong>。因此，服务器集群看起来形成了一个高可靠的状态机。</p><p>实际系统中使用的一致性算法通常含有以下特性：</p><ul><li>安全性保证（绝对不会返回一个错误的结果）：在非拜占庭错误情况下，包括网络延迟、分区、丢包、重复和乱序等错误都可以保证正确。（首先，非拜占庭错误通常指的是那些可能导致信息丢失或延迟，但不会导致错误信息被故意伪造的错误。这类错误包括但不限于网络延迟、网络分区（网络中断导致节点间无法通信）、数据包丢失、数据重复发送以及数据乱序等问题。其次，拜占庭错误则是指那些可能涉及恶意行为，如节点故意发送错误信息的情况。这种错误更为复杂，因为它们涉及到系统的安全问题，而不仅仅是信息的准确传递）</li><li>可用性：集群中只要有大多数的机器可运行并且能够相互通信、和客户端通信，就可以保证可用。因此，一个典型的包含 5 个节点的集群可以容忍两个节点的失败。服务器被停止就认为是失败。它们稍后可能会从可靠存储的状态中恢复并重新加入集群。</li><li>不依赖时序来保证一致性：物理时钟错误或者极端的消息延迟只有在最坏情况下才会导致可用性问题。</li><li>通常情况下，一条指令可以尽可能快的在集群中大多数节点响应一轮远程过程调用时完成。小部分比较慢的节点不会影响系统整体的性能。（通常情况下，一条指令可以尽可能快的在集群中大多数节点响应一轮远程过程调用时完成。小部分比较慢的节点不会影响系统整体的性能）</li></ul><h2 id="3-Paxos-算法的问题（不重要）"><a href="#3-Paxos-算法的问题（不重要）" class="headerlink" title="3 Paxos 算法的问题（不重要）"></a>3 Paxos 算法的问题（不重要）</h2><p>在过去的 10 年里，Leslie Lamport 的 Paxos 算法几乎已经成为一致性的代名词：Paxos 是在课程教学中最经常使用的算法，同时也是大多数一致性算法实现的起点。Paxos 首先定义了一个能够达成单一决策一致的协议，比如单条的复制日志项。我们把这一子集叫做单决策 Paxos。然后通过组合多个 Paxos 协议的实例来促进一系列决策的达成。Paxos 保证安全性和活性，同时也支持集群成员关系的变更。Paxos 的正确性已经被证明，在通常情况下也很高效。</p><p>不幸的是，Paxos 有两个明显的缺点。第一个缺点是 Paxos 算法特别的难以理解。完整的解释是出了名的不透明；通过极大的努力之后，也只有少数人成功理解了这个算法。因此，有了几次用更简单的术语来解释 Paxos 的尝试。尽管这些解释都只关注了单决策的子集问题，但依然很具有挑战性。在 2012 年 NSDI 的会议中的一次调查显示，很少有人对 Paxos 算法感到满意，甚至在经验老道的研究者中也是如此。我们自己也尝试去理解 Paxos；我们一直没能理解 Paxos 直到我们读了很多对 Paxos 的简化解释并且设计了我们自己的算法之后，这一过程花了近一年时间。</p><p>我们假设 Paxos 的不透明性来自它选择单决策问题作为它的基础。单决策 Paxos 是晦涩微妙的，它被划分成了两种没有简单直观解释和无法独立理解的情景。因此，这导致了很难建立起直观的感受为什么单决策 Paxos 算法能够工作。构成多决策 Paxos 增加了很多错综复杂的规则。我们相信，在多决策上达成一致性的问题（一份日志而不是单一的日志记录）能够被分解成其他的方式并且更加直接和明显。</p><p>Paxos算法的第二个问题就是它没有提供一个足够好的用来构建一个现实系统的基础。一个原因是还没有一种被广泛认同的多决策问题的算法。Lamport 的描述基本上都是关于单决策 Paxos 的；他简要描述了实施多决策 Paxos 的方法，但是缺乏很多细节。当然也有很多具体化 Paxos 的尝试，但是他们都互相不一样，和 Paxos 的概述也不同。例如 Chubby 这样的系统实现了一个类似于 Paxos 的算法，但是大多数的细节并没有被公开。</p><p>而且，Paxos 算法的结构也不是十分易于构建实践的系统；单决策分解也会产生其他的结果。例如，独立地选择一组日志条目然后合并成一个序列化的日志并没有带来太多的好处，仅仅增加了不少复杂性。围绕着日志来设计一个系统是更加简单高效的；新日志条目以严格限制的顺序增添到日志中去。另一个问题是，Paxos 使用了一种对等的点对点的方式作为它的核心（尽管它最终提议了一种弱领导人的方法来优化性能）。在只有一个决策会被制定的简化世界中是很有意义的，但是很少有现实的系统使用这种方式。如果有一系列的决策需要被制定，首先选择一个领导人，然后让他去协调所有的决议，会更加简单快速。</p><p>因此，实际的系统中很少有和 Paxos 相似的实践。每一种实现都是从 Paxos 开始研究，然后发现很多实现上的难题，再然后开发了一种和 Paxos 明显不一样的结构。这样是非常费时和容易出错的，并且理解 Paxos 的难度使得这个问题更加糟糕。Paxos 算法在理论上被证明是正确可行的，但是现实的系统和 Paxos 差别是如此的大，以至于这些证明没有什么太大的价值。下面来自 Chubby 实现非常典型：</p><p>在Paxos算法描述和实现现实系统中间有着巨大的鸿沟。最终的系统建立在一种没有经过证明的算法之上。</p><p>由于以上问题，我们认为 Paxos 算法既没有提供一个良好的基础给实践的系统，也没有给教学很好的帮助。基于一致性问题在大规模软件系统中的重要性，我们决定看看我们是否可以设计一个拥有更好特性的替代 Paxos 的一致性算法。Raft 算法就是这次实验的结果。</p><h2 id="4-为了可理解性的设计"><a href="#4-为了可理解性的设计" class="headerlink" title="4 为了可理解性的设计"></a>4 为了可理解性的设计</h2><p>设计 Raft 算法我们有几个初衷：<strong>它必须提供一个完整的实际的系统实现基础，这样才能大大减少开发者的工作；它必须在任何情况下都是安全的并且在大多数的情况下都是可用的；并且它的大部分操作必须是高效的</strong>。但是我们最重要也是最大的挑战是可理解性。它必须保证对于普遍的人群都可以十分容易的去理解。另外，它必须能够让人形成直观的认识，这样系统的构建者才能够在现实中进行必然的扩展。</p><p>在设计 Raft 算法的时候，有很多的点需要我们在各种备选方案中进行选择。在这种情况下，我们评估备选方案基于可理解性原则：解释各个备选方案有多大的难度（例如，Raft 的状态空间有多复杂，是否有微妙的暗示）？对于一个读者而言，完全理解这个方案和暗示是否容易？</p><p>我们意识到对这种可理解性分析上具有高度的主观性；尽管如此，我们使用了两种通常适用的技术来解决这个问题。第一个技术就是众所周知的<strong>问题分解</strong>：我们尽可能地将问题分解成几个相对独立的，可被解决的、可解释的和可理解的子问题。例如，<strong>Raft 算法被我们分成领导人选举，日志复制，安全性和成员变更</strong>几个部分。</p><p>我们使用的第二个方法是通过减少状态的数量来简化需要考虑的状态空间，使得系统更加连贯并且在可能的时候消除不确定性。特别的，所有的日志是不允许有空洞的，并且 Raft 限制了日志之间变成不一致状态的可能。（这里的”减少状态的数量来简化需要考虑的状态空间”意味着<strong>通过某种方法来限制或合并可能的状态，以便于减少系统分析或处理的复杂性</strong>。这样做的目的是使系统的行为更加可预测和连贯。而”所有的日志是不允许有空洞”这一点表明，在记录系统事件或操作的日志中，不允许出现缺失的信息或间断。换句话说，<strong>日志必须是连续的，没有遗漏任何发生的事件</strong>。这样可以确保日志的完整性和可靠性，从而使得基于这些日志进行的任何分析或重现都是准确的。举个例子，如果一个系统需要记录用户的操作，那么每一个操作都必须被记录下来，不能有遗漏。这样，如果需要回溯用户的行为或者检查系统的某个特定状态，就可以准确地通过日志来查看当时发生了什么，而不会遇到由于日志不完整导致无法确定系统状态的况）</p><p>尽管在大多数情况下我们都试图消除不确定性，但是也有一些情况下不确定性可以提升可理解性。尤其是，随机化方法增加了不确定性，但是他们有利于减少状态空间数量，通过处理所有可能选择时使用相似的方法。我们使用随机化来简化 Raft 中领导人选举算法（以Raft一致性算法中的领导者选举为例，Raft算法使用随机定时器来实现领导者选举。当一个节点发现当前没有领导者时，它会从一定的时间范围内随机选择一个超时值来设置自己的选举定时器。当定时器到期时，节点就会宣布自己成为候选人并开始新一轮的选举。这种随机化的方法增加了选举过程中的不确定性，因为每个节点可能会选择不同的超时时间。然而，这种不确定性实际上有助于减少系统需要处理的状态数量，因为算法不需要精确地协调各个节点的行为或预测具体的网络延迟。相反，由于随机化的存在，大多数情况下都会产生一个明确的胜出者，而不需要复杂的额外逻辑来确定领导者。因此，通过随机化方法，Raft算法能够在保持简洁性和效率的同时解决领导者选举问题。这种方法不仅减少了状态空间的大小，还使得算法更加可靠和易于理解）</p><h2 id="5-Raft-一致性算法"><a href="#5-Raft-一致性算法" class="headerlink" title="5 Raft 一致性算法"></a>5 Raft 一致性算法</h2><p>Raft 通过选举一个杰出的领导人，然后给予他全部的管理复制日志的责任来实现一致性。领导人从客户端接收日志条目（log entries），<strong>把日志条目复制到其他服务器上，并告诉其他的服务器什么时候可以安全地将日志条目应用到他们的状态机中</strong>。拥有一个领导人大大简化了对复制日志的管理。例如，领导人可以决定新的日志条目需要放在日志中的什么位置而不需要和其他服务器商议，并且数据都从领导人流向其他服务器。一个领导人可能会发生故障，或者和其他服务器失去连接，在这种情况下一个新的领导人会被选举出来。</p><p>通过领导人的方式，Raft 将一致性问题分解成了三个相对独立的子问题，这些问题会在接下来的子章节中进行讨论：</p><ul><li><strong>领导选举</strong>：当现存的领导人发生故障的时候, 一个新的领导人需要被选举出来（章节 5.2）</li><li><strong>日志复制</strong>：领导人必须从客户端接收日志条目（log entries）然后复制到集群中的其他节点，并强制要求其他节点的日志和自己保持一致。</li><li><strong>安全性</strong>：在 Raft 中安全性的关键是在图 3 中展示的状态机安全：如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一个不同的指令。备注：（假设你有一个分布式数据库系统，它使用一个复制状态机来保持一致性。这个数据库系统在多个服务器上复制了相同的数据，并且所有的写操作都是通过日志条目来记录的。这些日志条目然后按照顺序被应用到每个服务器的状态机中，以确保所有服务器上的数据保持一致。现在，假设服务器A接收到了一个写操作，这个操作被转化为一个日志条目并应用到了它的状态机中。这个操作改变了某个数据项的值。根据上述规则，其他任何服务器（比如服务器B和服务器C）都不能在同一个日志索引位置应用一个不同的指令。这意味着，如果服务器B和服务器C已经应用了之前的日志条目，并且他们的状态与服务器A在应用这个新的日志条目之前是一致的，那么他们也必须以相同的方式应用这个新的日志条目。如果他们尝试在同一个位置应用一个不同的指令，那么就会导致数据不一致。）</li></ul><p>在展示一致性算法之后，这一章节会讨论一些可用性的问题和计时在系统中的作用。</p><p><strong>状态</strong>：</p><p>所有服务器上的持久性状态 (在响应 RPC 请求之前，已经更新到了稳定的存储设备)</p><p>备注：（这句话的意思是，在分布式系统中，当一个服务器节点响应远程过程调用（RPC）请求之前，它已经将其状态更新（或持久化）到了稳定的存储设备中。这里的“持久性状态”指的是那些已经被写入并且可以预期在未来访问时仍然存在的状态信息。让我们分解一下这个句子的关键部分来更好地理解其含义：</p><ol><li><strong>所有服务器上的</strong>：指的是分布式系统中的每个服务器节点。</li><li><strong>持久性状态</strong>：是指那些已经被保存并且即使在系统故障后也能恢复的状态。这种状态通常被写入到磁盘或其他类型的非易失性存储设备中。</li><li><strong>在响应 RPC 请求之前</strong>：指的是在服务器完成处理客户端的请求并发送回应之前的时刻。</li><li><strong>已经更新到了稳定的存储设备</strong>：表示状态变更不仅仅在内存中进行，而是已经被确保写入到了可靠的存储介质上，如硬盘驱动器、固态驱动器或分布式文件系统等。</li></ol><p>在分布式系统中，保证状态的持久性是至关重要的，因为它确保了数据的可靠性和一致性。例如，在实现分布式数据库或日志复制的服务时，一个常见的要求是，在确认一个写操作（比如，一个数据库事务或日志条目的应用）之前，必须将其持久化到稳定的存储中。这样做是为了确保，即使发生系统崩溃或电力中断，更新后的状态也不会丢失，从而可以在系统恢复后重新构建起来。</p><p>此外，在某些一致性算法（如Raft或Paxos）中，持久化状态是算法正确性和系统稳定性的关键组成部分。在这些算法中，只有在状态被安全地写入到稳定存储之后，相关的变更才会被认为是已提交的，并且对客户端可见。）</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>currentTerm</td><td>服务器已知最新的任期（在服务器首次启动时初始化为0，单调递增）</td></tr><tr><td>votedFor</td><td>当前任期内收到选票的 candidateId，如果没有投给任何候选人 则为空</td></tr><tr><td>log[]</td><td>日志条目；每个条目包含了用于状态机的命令，以及领导人接收到该条目时的任期（初始索引为1）</td></tr></tbody></table><p>备注：（这些参数通常与分布式系统中的一致性算法相关，特别是类似于Raft这样的共识算法。在这类算法中，服务器节点需要通过选举来达成一致，并确保系统中的命令按照相同的顺序被执行。下面是这些参数的具体含义：</p><ol><li><strong>currentTerm</strong>: 这是当前服务器所知道的任期（Term）编号。任期是一个连续递增的数字，用于标识不同的领导者选举周期。每当开始新的选举时，任期号就会增加。这个参数对于同步服务器节点之间的状态非常重要。例如，在一个任期内，如果一个服务器已经投票给了某个候选人，但在该任期结束之前没有选出最终的领导者，那么在下一个任期开始时，它可能需要重新投票。</li><li><strong>votedFor</strong>: 这是一个标识符，表示当前任期内服务器已经投票支持的候选人（candidate）。每个候选人都有一个唯一的标识符（candidateId），当服务器向某个候选人投票时，会记录下这个标识符。如果服务器还没有投票给任何候选人，则此值为空。</li><li><strong>log[]</strong>: 这是一个日志条目数组，其中包含了一系列的命令（commands）。每个条目都代表了一个操作，这些操作将被应用到状态机上以改变系统的状态。每个日志条目还包含了创建该条目时的任期号。这个信息很重要，因为它确保了命令是按照特定的顺序被执行的，即使在发生领导者变更的情况下也是如此。</li></ol><p>这些参数是实现一致性算法的关键部分，它们帮助确保即使在不稳定的网络条件下，分布式系统也能够正确地达成共识并处理请求。）</p><p>所有服务器上的易失性状态</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>commitIndex</td><td>已知已提交的最高的日志条目的索引（初始值为0，单调递增）</td></tr><tr><td>lastApplied</td><td>已经被应用到状态机的最高的日志条目的索引（初始值为0，单调递增）</td></tr></tbody></table><p>备注：（在分布式系统中，特别是在使用Raft一致性算法的环境中，这两个参数是至关重要的：</p><ul><li><strong>commitIndex</strong>: 这个参数指示了已经被集群中大多数节点保存（或称提交）的日志条目的位置。在Raft算法中，一个日志条目只有在被多数节点存储后才能被认为是已经提交的。这意味着，如果一个日志条目的索引号小于或等于commitIndex，那么这个条目已经被提交，可以安全地应用到状态机中去。</li><li><strong>lastApplied</strong>: 这个参数则表示那些已经被应用到状态机的日志条目的索引。在实际应用中，一旦日志条目被提交，它就可以按照顺序被应用到状态机中，从而更新系统的状态。lastApplied是一个单调递增的值，它总是小于或等于commitIndex，因为只有已提交的日志条目才能被应用。</li></ul><p>此外，在系统重启后，这些参数可以通过重放日志和快照来恢复，因此它们不需要被持久化存储。这是因为Raft算法确保了即使在系统崩溃后，也可以通过领导者的matchIndex和其他机制来恢复这些值。）</p><p>领导人（服务器）上的易失性状态 (选举后已经重新初始化)</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>nextIndex[]&#x2F;nextIndex</td><td>对于每一台服务器，发送到该服务器的下一个日志条目的索引（初始值为领导人最后的日志条目的索引+1）</td></tr><tr><td>matchIndex[]&#x2F;matchIndex</td><td>对于每一台服务器，已知的已经复制到该服务器的最高日志条目的索引（初始值为0，单调递增）</td></tr></tbody></table><p><strong>备注：（</strong></p><p>nextIndex[]和matchIndex[]在功能上有一定的重叠。它们都是用于跟踪Raft协议中各个节点的状态。</p><p>nextIndex[]是一个数组，用于存储Leader节点向每个Follower节点发送下一个日志条目的索引。当Leader收到Follower的确认消息时，它会更新该Follower对应的nextIndex值，以便继续发送后续的日志条目。</p><p>matchIndex[]也是一个数组，用于存储Leader节点已经成功复制到每个Follower节点的最大日志条目索引。当Leader收到Follower的确认消息时，它会更新该Follower对应的matchIndex值，表示该Follower已经接收并应用了该索引之前的所有日志条目。</p><p>尽管nextIndex[]和matchIndex[]在某种程度上有重叠，但它们的用途略有不同。nextIndex[]主要用于控制Leader向Follower发送日志条目的顺序，而matchIndex[]则用于跟踪已复制的日志条目。在某些情况下，这两个数组的值可能会相同，但在其他情况下，它们可能有所不同<strong>）</strong></p><p><strong>追加条目（AppendEntries）RPC</strong>：</p><p>由领导人调用，用于日志条目的复制，同时也被当做心跳使用</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>领导人的任期</td></tr><tr><td>leaderId</td><td>领导人 ID 因此跟随者可以对客户端进行重定向（译者注：跟随者根据领导人 ID 把客户端的请求重定向到领导人，比如有时客户端把请求发给了跟随者而不是领导人）</td></tr><tr><td>prevLogIndex</td><td>紧邻新日志条目之前的那个日志条目的索引</td></tr><tr><td>prevLogTerm</td><td>紧邻新日志条目之前的那个日志条目的任期</td></tr><tr><td>entries[]</td><td>需要被保存的日志条目（被当做心跳使用时，则日志条目内容为空；为了提高效率可能一次性发送多个）</td></tr><tr><td>leaderCommit</td><td>领导人的已知已提交的最高的日志条目的索引</td></tr></tbody></table><p>备注：（追加条目（AppendEntries）远程过程调用（RPC）是Raft一致性算法中的一个关键组成部分，它用于在分布式系统中的服务器节点之间复制日志条目。这个RPC由领导者节点发起，并且有多个目的：</p><ol><li><strong>日志复制</strong>：领导者使用AppendEntries RPC将新的日志条目复制到跟随者节点。当领导者节点接收到客户端请求并创建了一个新的日志条目后，它会并发地向所有跟随者发送AppendEntries RPC，以复制这个新的条目。</li><li><strong>心跳</strong>：由于AppendEntries RPC被周期性地发送，它也充当了领导者对跟随者的心跳信号。跟随者通过定期接收这些RPC来确认领导者的存在和活跃性。<strong>如果跟随者在一定时间内没有收到来自领导者的AppendEntries RPC，它会认为领导者可能已经宕机，从而触发新一轮的领导选举</strong>。</li><li><strong>一致性保证</strong>：AppendEntries RPC还包含一些机制来确保系统一致性。例如，它包含了上一个已提交的日志条目的索引和任期号，跟随者节点使用这些信息来判断是否可以安全地应用其日志中的条目到状态机中。</li><li><strong>跟随者进度</strong>：通过AppendEntries RPC，领导者还可以追踪每个跟随者的进度。跟随者会在响应中返回它们已经应用到状态机的日志条目的索引，以及当前已知的最高日志条目的索引（matchIndex）。这允许领导者了解哪些日志条目已经被大多数节点接受，并据此推进commitIndex。</li></ol><p>总的来说，AppendEntries RPC是Raft算法实现分布式日志复制和一致性的核心机制之一。它不仅确保了日志条目在集群中的传播，而且还提供了领导者选举和故障检测的功能。</p><p>解释每个参数的含义：</p><ol><li><strong>term</strong>: 领导人的任期。这是一个连续递增的数字，用于标识领导人选举周期。如果跟随者收到的AppendEntries RPC中的任期号小于其当前已知的任期号，那么它会拒绝这个RPC并可能触发一次新的选举。</li><li><strong>leaderId</strong>: 领导人ID。这是当前领导者的唯一标识符。跟随者可以使用这个ID来重定向客户端的请求。例如，如果客户端将请求发送到了一个跟随者而不是领导者，跟随者可以根据leaderId将请求重定向到当前的领导者。</li><li><strong>prevLogIndex</strong>: 紧邻新日志条目之前的那个日志条目的索引。这个参数用于指定领导者在日志中最后一个已复制条目的位置。跟随者会检查自己的日志来确定是否已经存储了该条目。</li><li><strong>prevLogTerm</strong>: 紧邻新日志条目之前的那个日志条目的任期。这个参数与prevLogIndex一起使用，确保了日志的连续性和一致性。如果跟随者的日志中不存在与prevLogIndex和prevLogTerm相匹配的条目，则跟随者会拒绝这个RPC。</li><li><strong>entries[]</strong>: 需要被保存的日志条目。这些是领导者希望跟随者复制的日志条目。当AppendEntries RPC被当做心跳使用时，entries数组可能为空，表示没有新的日志条目需要复制。为了提高效率，领导者可能会一次性发送多个日志条目。</li><li><strong>leaderCommit</strong>: 领导人的已知已提交的最高的日志条目的索引。这个参数告诉跟随者领导者认为哪个日志条目已经被大多数节点存储并可以安全地应用到状态机中。跟随者可以使用这个信息来更新自己的commitIndex，并据此推进自己的状态机。</li></ol><p>）</p><table><thead><tr><th>返回值</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>当前任期，对于领导人而言 它会更新自己的任期</td></tr><tr><td>success</td><td>如果跟随者所含有的条目和 prevLogIndex 以及 prevLogTerm 匹配上了，则为 true</td></tr></tbody></table><p>备注（接收者的实现：这些参数是Raft算法中追加条目（AppendEntries）RPC的响应部分，它们用于领导者节点和跟随者节点之间的通信。下面我会详细解释每个返回值的含义：</p><ol><li><strong>term</strong>: 当前任期。这是追加条目RPC响应中的一个重要信息，它表示跟随者所认为的当前任期号。对于领导人来说，这个信息非常重要，因为如果响应中的任期号大于领导人当前的任期号，那么领导人就知道它已经失去了领导地位（因为它的任期已经过时了），于是它会转变为跟随者状态并开始新的选举过程。</li><li><strong>success</strong>: 如果跟随者所含有的条目和prevLogIndex以及prevLogTerm匹配上了，则为true。这个标志位表示跟随者是否成功复制了日志条目。当领导者发送一个追加条目RPC时，它包含了prevLogIndex和prevLogTerm来指示跟随者在它的日志中应该找到的最后一个条目的位置和任期。如果跟随者找到了与这些参数匹配的条目，那么它就会设置success为true，并将新的日志条目存储在自己的日志中。）</li></ol><p><strong>请求投票（RequestVote）RPC</strong>：</p><p>由候选人负责调用用来征集选票（5.2 节）</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>候选人的任期号</td></tr><tr><td>candidateId</td><td>请求选票的候选人的 ID</td></tr><tr><td>lastLogIndex</td><td>候选人的最后日志条目的索引值</td></tr><tr><td>lastLogTerm</td><td>候选人最后日志条目的任期号</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>当前任期号，以便于候选人去更新自己的任期号</td></tr><tr><td>voteGranted</td><td>候选人赢得了此张选票时为真</td></tr></tbody></table><p>备注（在Raft一致性算法中，请求投票（RequestVote）RPC是用于领导者选举过程中的。当一个服务器节点想要成为领导者时，它会向集群中的其他服务器发送RequestVote RPC来征集选票。下面是这些参数的具体含义：</p><ol><li><strong>term</strong>: 候选人的任期号。这是发起RequestVote RPC的候选人所在的任期。任期是一个连续递增的数字，用于区分不同的选举周期。如果响应者的当前任期大于或等于请求中的任期，那么它不会投票给这个候选人，因为这表示已经有一个更新的选举周期开始。</li><li><strong>candidateId</strong>: 请求选票的候选人的ID。这是一个唯一标识符，用于标识请求选票的服务器节点。</li><li><strong>lastLogIndex</strong>: 候选人的最后日志条目的索引值。这个参数表示候选人所持有的日志的最后一条条目的索引位置。这用于告知其他服务器节点候选人的日志状态，以便它们判断是否应该投票给该候选人。</li><li><strong>lastLogTerm</strong>: 候选人最后日志条目的任期号。这个参数与lastLogIndex一起使用，表示候选人最后一条日志条目的任期。这也是为了让其他服务器节点判断候选人的日志是否是最新的。</li></ol><p>返回值的含义如下：</p><ol><li><strong>term</strong>: 当前任期号。这是响应者所在的任期。如果这个值大于RequestVote RPC中的任期，那么这意味着候选人的任期已经过时，他需要更新自己的任期并重新开始选举过程。</li><li><strong>voteGranted</strong>: 候选人赢得了此张选票时为真。如果响应者决定投票给候选人，它会设置这个值为true。这通常发生在响应者的日志至少和候选人一样新，并且它们没有投票给其他候选人的情况下。</li></ol><p>通过RequestVote RPC，候选人可以收集足够的选票来成为领导者。当一个候选人收到大多数服务器的投票后，它就会成为新的领导者，并开始它的任期。）</p><p>接收者实现：</p><ol><li>如果term &lt; currentTerm返回 false （5.2 节）</li><li>如果 votedFor 为空或者为 candidateId，并且候选人的日志至少和自己一样新，那么就投票给他（5.2 节，5.4 节）</li></ol><p><strong>所有服务器需遵守的规则</strong>：</p><p>所有服务器：</p><ul><li><strong>如果<strong><strong>commitIndex &gt; lastApplied</strong></strong>，则 lastApplied 递增</strong>，并将log[lastApplied]应用到状态机中（5.3 节）</li><li>如果接收到的 RPC 请求或响应中，任期号T &gt; currentTerm，则令 currentTerm &#x3D; T，并切换为跟随者状态（5.1 节）</li></ul><p>备注（</p><ol><li><strong>所有服务器：如果commitIndex &gt; lastApplied，则lastApplied递增，并将log[lastApplied]应用到状态机中（5.3 节）</strong>这条规则描述了服务器节点如何将日志条目应用到其状态机中。在Raft算法中，每个服务器都有一个commitIndex，表示已经提交的最高日志条目的索引，以及一个lastApplied，表示已经应用到状态机的最高的日志条目的索引。当commitIndex超过lastApplied时，这意味着有新的日志条目已经被提交并可以安全地应用到状态机中。因此，服务器会递增lastApplied并将对应的日志条目（log[lastApplied]）应用到状态机中，从而更新系统的状态。</li><li><strong>如果接收到的RPC请求或响应中，任期号T &gt; currentTerm，则令currentTerm &#x3D; T，并切换为跟随者状态（5.1 节）</strong>这条规则描述了服务器节点如何处理任期号的变化。在Raft算法中，每个服务器都有一个currentTerm，表示当前所在的任期。当服务器接收到任何RPC（例如AppendEntries或RequestVote）时，它会检查RPC中的任期号T。如果T大于服务器的currentTerm，这意味着服务器的任期信息已经过时，可能错过了一次或多次领导者选举。因此，服务器会更新自己的currentTerm为T，并切换到跟随者状态，以便开始新一轮的领导者选举过程。）</li></ol><p>跟随者（5.2 节）：</p><ol><li><strong>响应来自候选人和领导人的请求</strong>：跟随者节点会响应两种类型的远程过程调用（RPC）：RequestVote（来自候选人）和AppendEntries（来自领导人）。对于RequestVote RPC，跟随者会根据自身的日志和任期信息来决定是否投票给该候选人。对于AppendEntries RPC，跟随者会根据领导人发送的信息来复制日志条目，并可能将新的日志条目应用到其状态机。</li><li><strong>如果在超过选举超时时间的情况之前没有收到当前领导人（即该领导人的任期需与这个跟随者的当前任期相同）的心跳&#x2F;附</strong>加日志，或者是给某个候选人投了票，就自己变成候选人：这是跟随者节点参与领导者选举的过程。Raft算法中的跟随者节点有一个选举超时（Election Timeout）机制，如果在这个超时周期内跟随者没有收到任何来自当前领导人的AppendEntries RPC（心跳或附加日志），它会假设没有活跃的领导人存在，并可能开始新一轮的选举。同样，如果跟随者给某个候选人投票后，没有收到该候选人成为领导人的消息，它也会认为需要开始新的选举。在这两种情况下，跟随者节点会将自己转变为候选人（Candidate）状态，并开始新的领导者选举过程。它会向其他服务器发送RequestVote RPC来征集选票，试图成为新的领导人。这是Raft算法确保系统即使在领导人失效的情况下仍能继续运行和保持活性的一种方式。</li></ol><p>候选人（5.2 节）：</p><ol><li><strong>在转变成候选人后就立即开始选举过程</strong>：成为候选人的节点会立即开始一个新的领导者选举过程。这是为了确保集群中有一个活跃的领导者来协调日志复制和状态机的应用。</li><li><strong>自增当前的任期号（currentTerm）</strong>：候选人会将其当前任期号（currentTerm）增加1，以表示一个新的选举周期的开始。任期号是一个连续递增的数字，用于区分不同的选举周期。</li><li><strong>给自己投票</strong>：候选人首先会给自己投一票，因为每个节点都希望成为领导人。</li><li><strong>重置选举超时计时器</strong>：候选人会设置一个选举超时计时器，如果在超时时间内没有收到大多数服务器的选票，那么它将认为当前选举失败，并可能再次尝试选举。</li><li><strong>发送请求投票的RPC给其他所有服务器</strong>：候选人会向集群中的其他服务器发送RequestVote RPC，试图获得足够的选票来成为领导人。</li><li><strong>如果接收到大多数服务器的选票，那么就变成领导人</strong>：如果候选人获得了超过半数的选票，它就会转变为领导人状态，并开始其领导任期，负责协调日志复制和状态机的应用。</li><li><strong>如果接收到来自新的领导人的附加日志（AppendEntries）RPC，则转变成跟随者</strong>：如果候选人在选举过程中收到了来自新领导人的AppendEntries RPC，这意味着另一个候选人已经赢得了选举。因此，该候选人会转变为跟随者状态，并响应新领导人的RPC。</li><li><strong>如果选举过程超时，则再次发起一轮选举</strong>：如果候选人的选举超时计时器到期，即在超时时间内没有成功赢得选举，它会再次增加任期号，并重新开始选举过程。</li></ol><p>领导人：</p><ul><li><p>一旦成为领导人：发送空的附加日志（AppendEntries）RPC（心跳）给其他所有的服务器；在一定的空余时间之后不停的重复发送，以防止跟随者超时（5.2 节）</p></li><li><p>如果接收到来自客户端的请求：附加条目到本地日志中，在条目被应用到状态机后响应客户端（5.3 节）</p></li><li><p>如果对于一个跟随者，最后日志条目的索引值大于等于 nextIndex（lastLogIndex ≥ nextIndex），则发送从 nextIndex 开始的所有日志条目：</p></li><li><ul><li>如果成功：更新相应跟随者的 nextIndex 和 matchIndex</li><li>如果因为日志不一致而失败，则 nextIndex 递减并重试</li></ul></li><li><p>假设存在 N 满足N &gt; commitIndex，使得大多数的 matchIndex[i] ≥ N以及log[N].term &#x3D;&#x3D; currentTerm 成立，则令 commitIndex &#x3D; N（5.3 和 5.4 节）</p></li></ul><p>备注（这段描述是关于Raft一致性算法中领导人（Leader）节点的行为。在Raft算法中，领导人节点负责协调日志复制和状态机的应用，以确保分布式系统中的一致性。下面是详细解释：</p><ol><li><strong>发送空的附加日志（AppendEntries）RPC（心跳）给其他所有的服务器</strong>：领导人会定期向所有跟随者发送AppendEntries RPC，这些RPC包含领导人的当前任期号和日志信息。这个所谓的“心跳”机制用来保持跟随者对领导人的认识，并防止跟随者因为等待心跳超时而开始新的选举。</li><li><strong>如果接收到来自客户端的请求：附加条目到本地日志中，在条目被应用到状态机后响应客户端</strong>：当领导人接收到客户端的请求时，它会将新的日志条目添加到本地日志中，并将该条目应用到其状态机。一旦应用完成，领导人会响应客户端，确认请求已被处理。</li><li><strong>领导者如果对于一个跟随者，最后日志条目的索引值大于等于 nextIndex（lastLogIndex ≥ nextIndex），则发送从 nextIndex 开始的所有日志条目</strong>：领导人会检查跟随者的日志是否至少与自己的日志一样新。如果不是这样，领导人将从nextIndex指定的日志条目开始，将所有缺失的日志条目发送给跟随者。lastLogIndex 通常是指领导人（Leader）节点的最后日志条目的索引值</li><li><strong>如果成功：更新相应跟随者的 nextIndex 和 matchIndex</strong>：如果日志复制成功，领导人会更新跟随者的nextIndex和matchIndex。nextIndex表示跟随者应该期望的下一个日志条目的索引，而matchIndex表示领导人已确认跟随者已经复制到的日志条目的最大索引。</li></ol><p>备注（</p><p>在 Raft 算法中，nextIndex 和 matchIndex 不是数组，而是单个的整数索引值。它们用于追踪日志复制的状态。让我来详细解释这两个概念：</p><p>nextIndex: 这个值对于每个跟随者节点来说都是特定的，并且由领导人维护。它代表了领导人下一次打算发送给特定跟随者的日志条目的索引。换句话说，它是领导人期望跟随者下一个要接收的日志条目的位置。当领导人向跟随者发送日志条目时，它会包含当前的 nextIndex 值，以便跟随者知道从哪个点开始接收日志。</p><p>matchIndex: 这个值也是由领导人维护的，对于每个跟随者节点都有一个对应的值。它表示领导人已经确认跟随者节点成功复制到的最大日志条目的索引。当跟随者成功复制一个日志条目并回复领导人时，领导人会更新该跟随者的 matchIndex。</p><p>在实际实现中，领导人可能会为集群中的每个跟随者维护一个结构，其中包含该跟随者的 nextIndex 和 matchIndex。这些值通常会被存储在某种形式的数据结构中，比如哈希表或者数组，以便快速查找和更新。但是，nextIndex 和 matchIndex 本身只是整数值，代表日志中的索引位置。</p><p>例如，如果领导人有一个日志，其最后一个条目的索引是 100，那么它可能会为一个跟随者设置 nextIndex 为 101，表示下一个要发送的日志条目的索引。如果跟随者成功复制了索引为 101 的日志条目，领导人会将该跟随者的 matchIndex 更新为 101，表示已经确认跟随者已经复制了至少到索引 101 的日志条目。</p><p>在实际实现中，领导人可能会为集群中的每个跟随者维护一个结构，其中包含该跟随者的 nextIndex 和 matchIndex。这些值通常会被存储在某种形式的数据结构中，比如哈希表或者数组，以便快速查找和更新。但是，nextIndex 和 matchIndex 本身只是整数值，代表日志中的索引位置。）</p><ol><li><strong>如果因为日志不一致而失败，则 nextIndex 递减并重试</strong>：如果在日志复制过程中发现不一致，领导人会递减nextIndex并重新尝试发送日志条目。这意味着领导人会回退到上一个已知一致的点，并从那里继续复制过程。</li></ol><p>备注（</p><p>在 Raft 算法中，当领导人尝试向跟随者复制日志条目时，可能会遇到不一致的情况。例如，跟随者可能已经存储了一些领导人不知道的日志条目，或者跟随者的日志条目与领导人的不匹配。这种情况下，领导人需要修正这种不一致，以确保所有节点最终能够达成一致的状态。</p><p>这里的描述是关于如何处理这种情况：</p><ol><li><ol><li><strong>日志不一致</strong>: 如果跟随者回复领导人一个错误，表明日志条目不能被应用（例如，因为任期号错误或日志条目不连续），这意味着发生了日志不一致。</li><li><strong>递减 nextIndex</strong>: 为了解决这个问题，领导人会将发送给该跟随者的 nextIndex 递减。这是因为 nextIndex 表示领导人希望跟随者下一个要接收的日志条目的索引。通过递减 nextIndex，领导人实际上是回退到上一个已知一致的日志条目，以便重新开始复制过程。</li><li><strong>重试发送日志条目</strong>: 领导人将从新的 nextIndex 指定的日志条目开始，重新发送缺失的日志条目给跟随者。这个过程会一直重复，直到跟随者成功复制了所有缺失的日志条目，从而解决了不一致问题。</li></ol></li></ol><p>这个机制确保了即使在出现不一致的情况下，Raft 算法也能够通过逐步回退和重试来修复问题，最终达到集群的一致性。这是 Raft 算法容错特性的一部分，允许系统在复杂的网络环境和潜在的节点故障中维持正常运行。）</p><ol><li><strong>假设存在 N 满足N &gt; commitIndex，使得大多数的 matchIndex[i] ≥ N以及log[N].term &#x3D;&#x3D; currentTerm 成立，则令 commitIndex &#x3D; N</strong>：领导人会检查是否可以提交日志条目到状态机。如果大多数服务器已经复制了某个日志条目（即matchIndex[i] &gt;&#x3D; N），并且该条目的任期号与当前任期号相同，那么领导人可以将该条目的索引设置为commitIndex，这意味着该条目可以安全地应用到状态机。</li></ol><p>通过这些步骤，Raft算法确保了分布式系统中的日志一致性和系统的活性。领导人通过心跳维持其领导地位，并通过日志复制和应用来协调集群中的状态。）</p><p><img src="https://github.com/maemual/raft-zh_cn/blob/master/images/raft-%E5%9B%BE2.png?raw=true" alt="img"></p><p>图 2：一个关于 Raft 一致性算法的浓缩总结（不包括成员变换和日志压缩）</p><p>Raft一致性算法的<strong>关键特性</strong>，它们确保了分布式系统中的日志复制和应用过程的正确性和一致性。</p><p>下面是每个特性的具体解释：</p><ol><li><strong>选举安全特性</strong>：这个特性保证了在给定的任期号内，只能有一个领导人被选举出来。这是为了防止出现脑裂（split-brain）情况，即同一任期内不能有多个领导人同时存在。</li><li><strong>领导人只附加原则</strong>：领导人节点不会删除或覆盖自己的日志，只会在现有日志的基础上增加新的条目。这意味着一旦日志条目被创建，它就会永久存在于日志中。</li><li><strong>日志匹配原则</strong>：如果两个日志在某个相同的索引位置具有相同任期号的日志条目，那么这两个日志在该索引之前的所有条目都是相同的。这个原则用于判断两个日志是否一致。</li><li><strong>领导人完全特性</strong>：如果一个日志条目在某个任期号中已经被提交，那么在所有后续的任期号中，所有的领导人都会包含这个条目。这确保了一旦某个日志条目被提交，它就不会被丢失。</li><li><strong>状态机安全特性</strong>：如果一个服务器已经将某个日志条目应用到了其状态机中，那么其他服务器在该条目的相同索引位置不会应用不同的日志条目。这个特性保证了系统的一致性，即所有服务器的状态机会以相同的顺序执行相同的操作。</li></ol><p>这些特性共同构成了Raft算法的基础，使得该算法能够在分布式环境中提供一致性保证，即使面临网络延迟、节点故障等问题也能正确运行。</p><p><img src="https://github.com/maemual/raft-zh_cn/raw/master/images/raft-%E5%9B%BE3.png" alt="img"></p><p>图 3：Raft 在任何时候都保证以上的各个特性。</p><h3 id="5-1-Raft-基础"><a href="#5-1-Raft-基础" class="headerlink" title="5.1 Raft 基础"></a>5.1 Raft 基础</h3><p>一个 Raft 集群包含若干个服务器节点；5 个服务器节点是一个典型的例子，这允许整个系统容忍 2 个节点失效。在任何时刻，每一个服务器节点都处于这三个状态之一：领导人、跟随者或者候选人。在通常情况下，系统中只有一个领导人并且其他的节点全部都是跟随者。跟随者都是被动的：他们不会发送任何请求，只是简单的响应来自领导人或者候选人的请求。领导人处理所有的客户端请求（如果一个客户端和跟随者联系，那么跟随者会把请求重定向给领导人）。第三种状态，候选人，是用来在 5.2 节描述的选举新领导人时使用。图 4 展示了这些状态和他们之间的转换关系；这些转换关系会在接下来进行讨论。</p><p><img src="https://github.com/maemual/raft-zh_cn/raw/master/images/raft-%E5%9B%BE4.png" alt="img"></p><p>图 4：服务器状态。</p><p>跟随者只响应来自其他服务器的请求。如果跟随者接收不到消息，那么他就会变成候选人并发起一次选举。获得集群中大多数选票的候选人将成为领导人。在一个任期内，领导人一直都会是领导人，直到自己宕机了。</p><p><img src="https://github.com/maemual/raft-zh_cn/raw/master/images/raft-%E5%9B%BE5.png" alt="img"></p><p>图 5：时间被划分成一个个的任期，每个任期始于一次选举。</p><p>在选举成功后，领导人会管理整个集群直到任期结束。有时候选举会失败，那么这个任期就会没有领导人而结束。任期之间的切换可以在不同的时间不同的服务器上观察到。</p><p>Raft 把时间分割成任意长度的<strong>任期</strong>，如图 5。任期用连续的整数标记。每一段任期从一次<strong>选举</strong>开始，就像章节 5.2 描述的一样，一个或者多个候选人尝试成为领导人。如果一个候选人赢得选举，然后他就在接下来的任期内充当领导人的职责。在某些情况下，一次选举过程会造成选票的瓜分。在这种情况下，这一任期会以没有领导人结束；一个新的任期（和一次新的选举）会很快重新开始。Raft 保证了在一个给定的任期内，最多只有一个领导人。</p><p>不同的服务器节点可能多次观察到任期之间的转换，但在某些情况下，一个节点也可能观察不到任何一次选举或者整个任期全程。任期在 Raft 算法中充当逻辑时钟的作用，任期使得服务器可以检测一些过期的信息：比如过期的领导人。每个节点存储一个当前任期号，这一编号在整个时期内单调递增。每当服务器之间通信的时候都会交换当前任期号；如果一个服务器的当前任期号比其他人小，那么他会更新自己的任期号到较大的任期号值。如果一个候选人或者领导人发现自己的任期号过期了，那么他会立即恢复成跟随者状态。如果一个节点接收到一个包含过期的任期号的请求，那么他会直接拒绝这个请求。</p><p>Raft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs。请求投票（RequestVote） RPCs 由候选人在选举期间发起（章节 5.2），然后附加条目（AppendEntries）RPCs 由领导人发起，用来复制日志和提供一种心跳机制（章节 5.3）。</p><p>第 7 节为了在服务器之间传输快照增加了第三种 RPC。当服务器没有及时的收到 RPC 的响应时，会进行重试， 并且他们能够并行的发起 RPCs 来获得最佳的性能。</p><p>备注（</p><p>这句话的意思是在Raft算法中，为了优化性能和处理日志落后的情况，增加了第三种RPC类型用于服务器之间的通信。具体来说：</p><ol><li><strong>RequestVote RPC</strong>：这是选举期间由候选者发起的RPC，用于请求其他服务器的投票。</li><li><strong>AppendEntries RPC</strong>：这是由领导人发起的RPC，作为一种心跳机制，用于复制日志条目到跟随者节点。</li><li><strong>InstallSnapshot RPC</strong>：这是新增的RPC类型，用于领导人向落后的跟随者发送快照，以帮助它们快速追赶上当前的日志状态。</li></ol><p>Raft算法通过这三种RPC实现了高效的日志复制和一致性维护。当服务器没有及时收到RPC响应时，它会尝试重发RPC，以确保消息传递的可靠性。同时，服务器能够并行地发起多个RPC，这样可以最大限度地提高网络和系统的利用率，从而获得最佳的性能）</p><h3 id="5-2-领导人选举"><a href="#5-2-领导人选举" class="headerlink" title="5.2 领导人选举"></a>5.2 领导人选举</h3><p>Raft 使用一种心跳机制来触发领导人选举。当服务器程序启动时，他们都是跟随者身份。一个服务器节点继续保持着跟随者状态只要他从领导人或者候选人处接收到有效的 RPCs。领导人周期性的向所有跟随者发送心跳包（即不包含日志项内容的附加条目（AppendEntries） RPCs）来维持自己的权威。如果一个跟随者在一段时间里没有接收到任何消息，也就是<strong>选举超时</strong>，那么他就会认为系统中没有可用的领导人,并且发起选举以选出新的领导人。</p><p>备注：成为领导人过程如下（</p><p>发起选举的过程是通过发送RequestVote RPC（远程过程调用）来完成的。具体步骤如下：</p><ol><li><strong>增加任期号</strong>：跟随者会将当前的任期号加1，表示开始了一个新的选举周期。</li><li><strong>发送RequestVote RPC</strong>：该跟随者作为候选者，向集群中的其他所有节点发送RequestVote RPC。这个RPC包含了候选者的任期号和日志信息。</li><li><strong>等待响应</strong>：候选者等待其他节点的响应。其他节点收到RequestVote RPC后，会根据自身的日志信息和任期号来决定是否投票给该候选者。</li><li><strong>统计投票</strong>：候选者会统计收到的投票。如果候选者获得了大多数节点的投票，那么它就成为了新的领导人。</li><li><strong>通知其他节点</strong>：一旦成为新的领导人，候选者会向其他节点发送心跳消息（AppendEntries RPC），通知它们自己已经成为了新的领导人。</li></ol><p>）</p><p>要开始一次选举过程，跟随者先要增加自己的当前任期号并且转换到候选人状态。然后他会并行地向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。候选人会继续保持着当前状态直到以下三件事情之一发生：(a) 他自己赢得了这次的选举，(b) 其他的服务器成为领导人，(c) 一段时间之后没有任何一个获胜的人。这些结果会分别的在下面的段落里进行讨论。</p><p>当一个候选人从整个集群的大多数服务器节点获得了针对同一个任期号的选票，那么他就赢得了这次选举并成为领导人。每一个服务器最多会对一个任期号投出一张选票，按照先来先服务的原则（注意：5.4 节在投票上增加了一点额外的限制）。要求大多数选票的规则确保了最多只会有一个候选人赢得此次选举（图 3 中的选举安全性）。一旦候选人赢得选举，他就立即成为领导人。<strong>然后他会向其他的服务器发送心跳消息来建立自己的权威并且阻止发起新的选举。</strong></p><p>备注（</p><p>一旦候选人赢得选举，他会立即成为领导人。然后他会向其他的服务器发送心跳消息来建立自己的权威并且阻止发起新的选举。具体来说，以下是领导人建立权威的步骤：</p><ol><li><strong>增加任期号</strong>：新当选的领导人会增加当前的任期号，表示开始了一个新的领导周期。</li><li><strong>发送心跳消息</strong>：领导人会定期向所有跟随者发送心跳消息，这些<strong>消息包含了领导人的任期号和日志信息</strong>。心跳消息的目的是告知跟随者自己仍然是活跃的领导人，并且维护日志的一致性。</li><li><strong>等待响应</strong>：跟随者在收到心跳消息后，会比较消息中的任期号与自己记录的任期号。如果消息中的任期号较新或者相同，跟随者会更新自己的任期号，<strong>并按照心跳消息中的日志信息更新自己的日志</strong>。</li><li><strong>防止新的选举</strong>：由于跟随者收到了领导人的心跳消息，<strong>它们不会因为超时而触发新的选举</strong>。这就确保了在当前领导人活跃的情况下，不会有新的选举发生。</li><li><strong>处理不一致的情况</strong>：如果在一段时间内跟随者没有收到心跳消息，它可能会认为领导人已经失效，并开始新的选举。但是，由于Raft算法的设计，这种情况的发生概率非常低。</li></ol><p>）</p><p>在等待投票的时候，<strong>候选人可能会从其他的服务器接收到声明它是领导人的附加条目（AppendEntries）RPC。如果这个领导人的任期号（包含在此次的 RPC中）不小于候选人当前的任期号，那么候选人会承认领导人合法并回到跟随者状态。</strong> 如果此次 RPC 中的任期号比自己小，那么候选人就会拒绝这次的 RPC 并且继续保持候选人状态。</p><p>第三种可能的结果是候选人既没有赢得选举也没有输：如果有多个跟随者同时成为候选人，那么选票可能会被瓜分以至于没有候选人可以赢得大多数人的支持。当这种情况发生的时候，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，没有其他机制的话，选票可能会被无限的重复瓜分。</p><p>Raft 算法使用随机选举超时时间的方法来确保很少会发生选票瓜分的情况，就算发生也能很快的解决。为了阻止选票起初就被瓜分，选举超时时间是从一个固定的区间（例如 150-300 毫秒）随机选择。这样可以把服务器都分散开以至于在大多数情况下只有一个服务器会选举超时；然后他赢得选举并在其他服务器超时之前发送心跳包。备注（由于每个节点的超时时间是独立随机选取的，因此它们不会同时超时。这意味着在大多数情况下，只有一个节点会首先超时并成为候选者，开始新一轮的领导选举过程。这样可以减少多个节点同时竞选导致的不必要的网络通信和竞争，从而提高系统的效率和稳定性。）同样的机制被用在选票瓜分的情况下。每一个候选人在开始一次选举的时候会重置一个随机的选举超时时间，然后在超时时间内等待投票的结果；这样减少了在新的选举中另外的选票瓜分的可能性。9.3 节展示了这种方案能够快速的选出一个领导人。</p><h3 id="5-3-日志复制"><a href="#5-3-日志复制" class="headerlink" title="5.3 日志复制"></a>5.3 日志复制</h3><p>一旦一个领导人被选举出来，他就开始为客户端提供服务。客户端的每一个请求都包含一条被复制状态机执行的指令。领导人把这条指令作为一条新的日志条目附加到日志中去，然后并行地发起附加条目 RPCs 给其他的服务器，让他们复制这条日志条目。当这条日志条目被安全地复制（下面会介绍），领导人会应用这条日志条目到它的状态机中然后把执行的结果返回给客户端。如果跟随者崩溃或者运行缓慢，再或者网络丢包，领导人会不断的重复尝试附加日志条目 RPCs （尽管已经回复了客户端）直到所有的跟随者都最终存储了所有的日志条目。</p><p><img src="https://github.com/maemual/raft-zh_cn/raw/master/images/raft-%E5%9B%BE6.png" alt="img"></p><p>图 6：日志由有序序号标记的条目组成。</p><p>每个条目都包含创建时的任期号（图中框中的数字），和一个状态机需要执行的指令。一个条目当可以安全地被应用到状态机中去的时候，就认为是可以提交了。 </p><p>日志以图 6 展示的方式组织。每一个日志条目存储一条状态机指令和从领导人收到这条指令时的任期号。<strong>日志中的任期号用来检查是否出现不一致的情况</strong>，同时也用来保证图 3 中的某些性质。每一条日志条目同时也都有一个整数索引值来表明它在日志中的位置。领导人来决定什么时候把日志条目应用到状态机中是安全的；这种日志条目被称为<strong>已提交</strong>。Raft 算法保证所有已提交的日志条目都是持久化的并且最终会被所有可用的状态机执行。在领导人将创建的日志条目复制到大多数的服务器上的时候，日志条目就会被提交（例如在图 6 中的条目 7）。</p><p>，领导人的日志中之前的所有日志条目也都会被提交，包括由其他领导人创建的条目。5.4 节会讨论某些当在领导人改变之后应用这条规则的隐晦内容，同时他也展示了这种提交的定义是安全的。领导人跟踪了最大的将会被提交的日志项的索引，并且索引值会被包含在未来的所有附加日志 RPCs （包括心跳包），这样其他的服务器才能最终知道领导人的提交位置。一旦跟随者知道一条日志条目已经被提交，那么他也会将这个日志条目应用到本地的状态机中（按照日志的顺序）。</p><p>我们设计了 Raft 的日志机制来维护不同服务器日志之间的高层次的一致性。这么做不仅简化了系统的行为也使其更具有可预测性，同时它也是安全性保证的一个重要组件。Raft 维护着以下的特性，这些特性共同组成了图 3 中的<strong>日志匹配特性（Log Matching Property）</strong>：</p><ul><li>如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。</li><li>如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也全部相同</li></ul><p><strong>第一个特性来自这样的一个事实，领导人最多在一个任期里在指定的一个日志索引位置创建一条日志条目，同时日志条目在日志中的位置也从来不会改变。第二个特性由附加日志 RPC 的一个简单的一致性检查所保证。在发送附加日志 RPC 的时候，领导人会把新的日志条目前紧挨着的条目的索引位置和任期号包含在日志内。如果跟随者在它的日志中找不到包含相同索引位置和任期号的条目，那么他就会拒绝接收新的日志条目。</strong>一致性检查就像一个归纳步骤：一开始空的日志状态肯定是满足日志匹配特性的，然后一致性检查在日志扩展的时候保护了日志匹配特性。因此，每当附加日志 RPC 返回成功时，领导人就知道跟随者的日志一定是和自己相同的了。</p><p>在正常的操作中，领导人和跟随者的日志保持一致性，所以附加日志 RPC 的一致性检查从来不会失败。然而，领导人崩溃的情况会使得日志处于不一致的状态（老的领导人可能还没有完全复制所有的日志条目）。这种不一致问题会在领导人和跟随者的一系列崩溃下加剧。图 7 展示了跟随者的日志可能和新的领导人不同。跟随者可能会丢失一些在新的领导人中存在的日志条目，他也可能拥有一些领导人没有的日志条目，或者两者都发生。丢失或者多出日志条目可能会持续多个任期。</p><p>备注（在Raft算法中，跟随者的日志中可能会出现比新领导者多的条目，这种情况通常是由于网络延迟或领导人崩溃导致的。具体来说，如果一个跟随者已经应用了一些日志条目，但这些条目还没有被领导人复制和确认，那么当领导人崩溃后，这个跟随者可能会提升为新的领导人。此时，它的日志中就会包含那些未被原领导人确认的条目。关于Term的问题，跟随者的日志中可能存在比新领导人的Term大的条目，但这并不意味着这些条目一定会被抛弃或立即应用。Raft算法会通过比较日志条目的索引和任期号来解决这种不一致问题。如果两个节点在某个特定索引位置的日志条目具有相同的任期号，那么从日志的开始到该索引位置之前的所有条目都应该是完全相同的。这意味着，如果跟随者的日志条目与新领导人的日志条目具有相同的索引和任期号，那么这些条目将被保留；否则，它们将被丢弃）</p><p><img src="https://github.com/maemual/raft-zh_cn/raw/master/images/raft-%E5%9B%BE7.png" alt="img"></p><p>图 7：当一个领导人成功当选时，跟随者可能是任何情况（a-f）</p><p>每一个盒子表示是一个日志条目；里面的数字表示任期号。跟随者可能会缺少一些日志条目（a-b），可能会有一些未被提交的日志条目（c-d），或者两种情况都存在（e-f）。例如，场景 f 可能会这样发生，某服务器在任期 2 的时候是领导人，已附加了一些日志条目到自己的日志中，但在提交之前就崩溃了；很快这个机器就被重启了，在任期 3 重新被选为领导人，并且又增加了一些日志条目到自己的日志中；在任期 2 和任期 3 的日志被提交之前，这个服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。</p><p>在 Raft 算法中，领导人是通过强制跟随者直接复制自己的日志来处理不一致问题的。这意味着在跟随者中的冲突的日志条目会被领导人的日志覆盖。5.4 节会阐述如何通过增加一些限制来使得这样的操作是安全的。</p><p>要使得跟随者的日志进入和自己一致的状态，领导人必须找到最后两者达成一致的地方，然后删除跟随者从那个点之后的所有日志条目，并发送自己在那个点之后的日志给跟随者。所有的这些操作都在进行附加日志 RPCs 的一致性检查时完成。领导人针对每一个跟随者维护了一个 <strong>nextIndex</strong>，这表示下一个需要发送给跟随者的日志条目的索引地址。当一个领导人刚获得权力的时候，他初始化所有的 nextIndex 值为自己的最后一条日志的 index 加 1（图 7 中的 11）。<strong>如果一个跟随者的日志和领导人不一致，那么在下一次的附加日志 RPC 时的一致性检查就会失败。在被跟随者拒绝之后，领导人就会减小 nextIndex 值并进行重试。最终 nextIndex 会在某个位置使得领导人和跟随者的日志达成一致。当这种情况发生，附加日志 RPC 就会成功，这时就会把跟随者冲突的日志条目全部删除并且加上领导人的日志。一旦附加日志 RPC 成功，那么跟随者的日志就会和领导人保持一致，并且在接下来的任期里一直继续保持。</strong></p><p>如果需要的话，算法可以通过减少被拒绝的附加日志 RPCs 的次数来优化。例如，当附加日志 RPC 的请求被拒绝的时候，跟随者可以(返回)冲突条目的任期号和该任期号对应的最小索引地址。借助这些信息，领导人可以减小 nextIndex 一次性越过该冲突任期的所有日志条目；这样就变成每个任期需要一次附加条目 RPC 而不是每个条目一次。在实践中，我们十分怀疑这种优化是否是必要的，因为失败是很少发生的并且也不大可能会有这么多不一致的日志。</p><p>通过这种机制，领导人在获得权力的时候就不需要任何特殊的操作来恢复一致性。他只需要进行正常的操作，然后日志就能在回复附加日志 RPC 的一致性检查失败的时候自动趋于一致。领导人从来不会覆盖或者删除自己的日志（图 3 的领导人只附加特性）。</p><p>日志复制机制展示出了第 2 节中形容的一致性特性：Raft 能够接受，复制并应用新的日志条目只要大部分的机器是工作的；在通常的情况下，新的日志条目可以在一次 RPC 中被复制给集群中的大多数机器；并且单个的缓慢的跟随者不会影响整体的性能。</p><h3 id="5-4-安全性"><a href="#5-4-安全性" class="headerlink" title="5.4 安全性"></a>5.4 安全性</h3><p>前面的章节里描述了 Raft 算法是如何选举和复制日志的。然而，到目前为止描述的机制并不能充分的保证每一个状态机会按照相同的顺序执行相同的指令。<strong>例如，一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目；因此，不同的状态机可能会执行不同的指令序列。</strong></p><p><strong>备注（</strong>这段话描述的是Raft一致性算法中处理网络分区和节点不可用的情况。在Raft算法中，如果一个跟随者（Follower）进入了不可用状态（例如因为网络故障或其他原因无法与领导人通信），同时领导人已经提交了一些日志条目，那么这个跟随者可能会错过这些已提交的条目。</p><p>如果这个不可用的跟随者随后被选举为新的领导人，它可能会覆盖之前领导人提交的日志条目。这是因为在Raft算法中，当一个节点成为领导人时，它会创建一个新的任期（Term）并开始自己的日志条目序列。因此，如果这个新领导人的日志与之前的领导人不一致，它可能会覆盖或丢弃之前的条目。</p><p>这种情况可能导致不同的状态机（State Machine）执行不同的指令序列。在分布式系统中，每个节点都有一个状态机，用于根据日志条目来更新系统的状态。如果不同的节点有不同的日志条目，那么它们的状态机可能会执行不同的操作，导致系统状态不一致<strong>）</strong></p><p>这一节通过在领导选举的时候增加一些限制来完善 Raft 算法。这一限制保证了任何的领导人对于给定的任期号，都拥有了之前任期的所有被提交的日志条目（图 3 中的领导人完整特性）。增加这一选举时的限制，我们对于提交时的规则也更加清晰。最终，我们将展示对于<strong>领导人完整特性（Leader Completeness Property）</strong> 的简要证明，并且说明该特性是如何引导复制状态机做出正确行为的。</p><h4 id="5-4-1-选举限制"><a href="#5-4-1-选举限制" class="headerlink" title="5.4.1 选举限制"></a>5.4.1 选举限制</h4><p>在任何基于领导人的一致性算法中，领导人都必须存储所有已经提交的日志条目。在某些一致性算法中，例如 Viewstamped Replication，某个节点即使是一开始并没有包含所有已经提交的日志条目，它也能被选为领导人。这些算法都包含一些额外的机制来识别丢失的日志条目并把他们传送给新的领导人，要么是在选举阶段要么在之后很快进行。不幸的是，这种方法会导致相当大的额外的机制和复杂性。</p><p>Raft 使用了一种更加简单的方法，它可以保证在选举的时候新的领导人拥有所有之前任期中已经提交的日志条目，而不需要传送这些日志条目给领导人。这意味着日志条目的传送是单向的，只从领导人传给跟随者，并且领导人从不会覆盖自身本地日志中已经存在的条目。</p><p>Raft 使用投票的方式来阻止一个候选人赢得选举，除非这个候选人包含了所有已经提交的日志条目。候选人为了赢得选举必须联系集群中的大部分节点，这意味着每一个已经提交的日志条目在这些服务器节点中肯定存在于至少一个节点上。如果候选人的日志至少和大多数的服务器节点一样新（这个新的定义会在下面讨论），那么他一定持有了所有已经提交的日志条目。请求投票（RequestVote） RPC 实现了这样的限制：RPC 中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。</p><p>Raft 通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。</p><h4 id="5-4-2-提交之前任期内的日志条目"><a href="#5-4-2-提交之前任期内的日志条目" class="headerlink" title="5.4.2 提交之前任期内的日志条目"></a>5.4.2 提交之前任期内的日志条目</h4><p>如同 5.3 节介绍的那样，领导人知道一条当前任期内的日志记录是可以被提交的，只要它被存储到了大多数的服务器上。如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录。</p><p>备注（这是因为在分布式系统中，即使一个日志条目已经被存储到大多数节点上，也可能会因为网络延迟、节点故障等原因导致该条目没有被所有节点正确地应用和提交。因此，即使一个日志条目已经被大多数节点存储，它仍然有可能被未来的领导人覆盖掉）</p><p><img src="https://github.com/maemual/raft-zh_cn/raw/master/images/raft-%E5%9B%BE8.png" alt="img"></p><p>图 8：如图的时间序列展示了为什么领导人无法决定对老任期号的日志条目进行提交。</p><p>在 (a) 中，S1 是领导人，部分的(跟随者)复制了索引位置 2 的日志条目。在 (b) 中，S1 崩溃了，然后 S5 在任期 3 里通过 S3、S4 和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2 处。然后到 (c)，S5 又崩溃了；S1 重新启动，选举成功，开始复制日志。在这时，来自任期 2 的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交。如果 S1 在 (d) 中又崩溃了，S5 可以重新被选举成功（通过来自 S2，S3 和 S4 的选票），然后覆盖了他们在索引 2 处的日志。反之，如果在崩溃之前，S1 把自己主导的新任期里产生的日志条目复制到了大多数机器上，就如 (e) 中那样，那么在后面任期里面这些新的日志条目就会被提交（因为 S5 就不可能选举成功）。 这样在同一时刻就同时保证了，之前的所有老的日志条目就会被提交。</p><p>为了消除图 8 里描述的情况，Raft 永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。只有领导人当前任期里的日志条目通过计算副本数目可以被提交；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。在某些情况下，领导人可以安全的知道一个老的日志条目是否已经被提交（例如，该条目是否存储到所有服务器上），但是 Raft 为了简化问题使用一种更加保守的方法。</p><p>当领导人复制之前任期里的日志时，Raft 会为所有日志保留原始的任期号, 这在提交规则上产生了额外的复杂性。在其他的一致性算法中，如果一个新的领导人要重新复制之前的任期里的日志时，它必须使用当前新的任期号。Raft 使用的方法更加容易辨别出日志，因为它可以随着时间和日志的变化对日志维护着同一个任期编号。另外，和其他的算法相比，Raft 中的新领导人只需要发送更少日志条目（其他算法中必须在他们被提交之前发送更多的冗余日志条目来为他们重新编号）。</p><p>备注（当没达到这个大多数同意，就当成消息执行失败就行了）</p><h4 id="5-4-3-安全性论证（没看）"><a href="#5-4-3-安全性论证（没看）" class="headerlink" title="5.4.3 安全性论证（没看）"></a>5.4.3 安全性论证（没看）</h4><p>在给定了完整的 Raft 算法之后，我们现在可以更加精确的讨论领导人完整性特性（这一讨论基于 9.2 节的安全性证明）。我们假设领导人完全性特性是不存在的，然后我们推出矛盾来。假设任期 T 的领导人（领导人 T）在任期内提交了一条日志条目，但是这条日志条目没有被存储到未来某个任期的领导人的日志中。设大于 T 的最小任期 U 的领导人 U 没有这条日志条目。</p><p><a href="https://github.com/maemual/raft-zh_cn/blob/master/images/raft-%E5%9B%BE9.png"><img src="https://github.com/maemual/raft-zh_cn/raw/master/images/raft-%E5%9B%BE9.png" alt="img"></a></p><p>图 9：如果 S1 （任期 T 的领导人）在它的任期里提交了一条新的日志，然后 S5 在之后的任期 U 里被选举为领导人，那么至少会有一个机器，如 S3，既拥有来自 S1 的日志，也给 S5 投票了。</p><ol><li>在领导人 U 选举的时候一定没有那条被提交的日志条目（领导人从不会删除或者覆盖任何条目）。</li><li>领导人 T 复制这条日志条目给集群中的大多数节点，同时，领导人 U 从集群中的大多数节点赢得了选票。因此，至少有一个节点（投票者、选民）同时接受了来自领导人 T 的日志条目，并且给领导人 U 投票了，如图 9。这个投票者是产生这个矛盾的关键。</li><li>这个投票者必须在给领导人 U 投票之前先接受了从领导人 T 发来的已经被提交的日志条目；否则他就会拒绝来自领导人 T 的附加日志请求（因为此时他的任期号会比 T 大）。</li><li>投票者在给领导人 U 投票时依然保存有这条日志条目，因为任何中间的领导人都包含该日志条目（根据上述的假设），领导人从不会删除条目，并且跟随者只有在和领导人冲突的时候才会删除条目。</li><li>投票者把自己选票投给领导人 U 时，领导人 U 的日志必须和投票者自己一样新。这就导致了两者矛盾之一。</li><li>首先，如果投票者和领导人 U 的最后一条日志的任期号相同，那么领导人 U 的日志至少和投票者一样长，所以领导人 U 的日志一定包含所有投票者的日志。这是另一处矛盾，因为投票者包含了那条已经被提交的日志条目，但是在上述的假设里，领导人 U 是不包含的。</li><li>除此之外，领导人 U 的最后一条日志的任期号就必须比投票人大了。此外，他也比 T 大，因为投票人的最后一条日志的任期号至少和 T 一样大（他包含了来自任期 T 的已提交的日志）。创建了领导人 U 最后一条日志的之前领导人一定已经包含了那条被提交的日志（根据上述假设，领导人 U 是第一个不包含该日志条目的领导人）。所以，根据日志匹配特性，领导人 U 一定也包含那条被提交的日志，这里产生矛盾。</li><li>这里完成了矛盾。因此，所有比 T 大的领导人一定包含了所有来自 T 的已经被提交的日志。</li><li>日志匹配原则保证了未来的领导人也同时会包含被间接提交的条目，例如图 8 (e) 中的索引 2。</li></ol><p>通过领导人完全特性，我们就能证明图 3 中的状态机安全特性，即如果服务器已经在某个给定的索引值应用了日志条目到自己的状态机里，那么其他的服务器不会应用一个不一样的日志到同一个索引值上。在一个服务器应用一条日志条目到他自己的状态机中时，他的日志必须和领导人的日志，在该条目和之前的条目上相同，并且已经被提交。现在我们来考虑在任何一个服务器应用一个指定索引位置的日志的最小任期；日志完全特性保证拥有更高任期号的领导人会存储相同的日志条目，所以之后的任期里应用某个索引位置的日志条目也会是相同的值。因此，状态机安全特性是成立的。</p><p>最后，Raft 要求服务器按照日志中索引位置顺序应用日志条目。和状态机安全特性结合起来看，这就意味着所有的服务器会应用相同的日志序列集到自己的状态机中，并且是按照相同的顺序。</p><h3 id="5-5-跟随者和候选人崩溃"><a href="#5-5-跟随者和候选人崩溃" class="headerlink" title="5.5 跟随者和候选人崩溃"></a>5.5 跟随者和候选人崩溃</h3><p>到目前为止，我们都只关注了领导人崩溃的情况。跟随者和候选人崩溃后的处理方式比领导人要简单的多，并且他们的处理方式是相同的。如果跟随者或者候选人崩溃了，那么后续发送给他们的 RPCs 都会失败。Raft 中处理这种失败就是简单地通过无限的重试；如果崩溃的机器重启了，那么这些 RPC 就会完整的成功。如果一个服务器在完成了一个 RPC，但是还没有响应的时候崩溃了，那么在他重新启动之后就会再次收到同样的请求。Raft 的 RPCs 都是幂等的，所以这样重试不会造成任何问题。例如一个跟随者如果收到附加日志请求但是他已经包含了这一日志，那么他就会直接忽略这个新的请求。</p><h3 id="5-6-时间和可用性"><a href="#5-6-时间和可用性" class="headerlink" title="5.6 时间和可用性"></a>5.6 时间和可用性</h3><p>Raft 的要求之一就是安全性不能依赖时间：整个系统不能因为某些事件运行的比预期快一点或者慢一点就产生了错误的结果。但是，可用性（系统可以及时的响应客户端）不可避免的要依赖于时间。例如，如果消息交换比服务器故障间隔时间长，候选人将没有足够长的时间来赢得选举；没有一个稳定的领导人，Raft 将无法工作。</p><p>领导人选举是 Raft 中对时间要求最为关键的方面。Raft 可以选举并维持一个稳定的领导人,只要系统满足下面的时间要求：</p><p>广播时间（broadcastTime） &lt;&lt; 选举超时时间（electionTimeout） &lt;&lt; 平均故障间隔时间（MTBF）</p><p>在这个不等式中，广播时间指的是从一个服务器并行的发送 RPCs 给集群中的其他服务器并接收响应的平均时间；选举超时时间就是在 5.2 节中介绍的选举的超时时间限制；然后平均故障间隔时间就是对于一台服务器而言，两次故障之间的平均时间。广播时间必须比选举超时时间小一个量级，这样领导人才能够发送稳定的心跳消息来阻止跟随者开始进入选举状态；通过随机化选举超时时间的方法，这个不等式也使得选票瓜分的情况变得不可能。选举超时时间应该要比平均故障间隔时间小上几个数量级，这样整个系统才能稳定的运行。当领导人崩溃后，整个系统会大约相当于选举超时的时间里不可用；我们希望这种情况在整个系统的运行中很少出现。</p><p>备注（</p><ul><li><strong>快速响应</strong>：当领导者节点发生故障时，系统需要能够迅速检测到这一情况并启动新的领导者选举。如果<strong>选举超时时间设置得太长，那么在领导者故障和新的领导者被选出之间会有较长的延迟</strong>，这段时间内系统可能无法正常处理请求，从而影响系统的可用性。</li><li><strong>避免不必要的等待</strong>：选举超时时间设置得比平均故障间隔时间短，可以确保即使领导者节点频繁发生故障，系统也能够及时地进行领导者选举，而不是让跟随者节点长时间等待一个可能已经失效的领导者的心跳消息。</li></ul><p>如果选举超时时间（electionTimeout）和平均故障间隔时间（MTBF）设置得太接近，确实可能会导致系统频繁地进行领导者选举，从而影响系统的稳定性和性能。</p><p>在分布式系统中，尤其是在使用Raft这样的一致性算法时，选举超时时间是一个关键参数。它决定了跟随者在没有收到领导者心跳消息时，需要等待多久才能认为领导者已经失效并开始新的选举。如果这个时间设置得太短，那么即使领导者还在正常运行，跟随者也可能会错误地认为领导者已经失效，从而引发不必要的领导者选举。</p><p>频繁的领导者选举会导致以下几个问题：</p><ol><li><strong>性能下降</strong>：每次选举都会占用系统资源，包括网络带宽和节点计算能力。频繁的选举会消耗大量资源，导致系统性能下降。</li><li><strong>服务不稳定</strong>：领导者的不断变更可能导致服务不稳定，因为每次选举后，新的领导者需要重新同步状态并处理请求，这可能会暂时中断服务。</li><li><strong>用户体验受损</strong>：如果用户请求经常遇到服务不可用或响应时间长，会影响用户体验。</li></ol><p>因此，为了避免这些问题，选举超时时间应该设置为一个合理的值，既能及时检测到领导者的故障，又不会因为太小而频繁触发不必要的选举）</p><p>广播时间和平均故障间隔时间是由系统决定的，但是选举超时时间是我们自己选择的。Raft 的 RPCs 需要接收方将信息持久化的保存到稳定存储中去，所以广播时间大约是 0.5 毫秒到 20 毫秒，取决于存储的技术。因此，选举超时时间可能需要在 10 毫秒到 500 毫秒之间。大多数的服务器的<strong>平均故障间隔时间</strong>都在几个月甚至更长，很容易满足时间的需求。</p><h2 id="6-集群成员变化"><a href="#6-集群成员变化" class="headerlink" title="6 集群成员变化"></a>6 集群成员变化</h2><p>到目前为止，我们都假设集群的配置（加入到一致性算法的服务器集合）是固定不变的。但是在实践中，偶尔是会改变集群的配置的，例如替换那些宕机的机器或者改变复制级别。尽管可以通过暂停整个集群，更新所有配置，然后重启整个集群的方式来实现，但是在更改的时候集群会不可用。另外，如果存在手工操作步骤，那么就会有操作失误的风险。为了避免这样的问题，我们决定自动化配置改变并且将其纳入到 Raft 一致性算法中来。</p><p>为了让配置修改机制能够安全，那么在转换的过程中不能够存在任何时间点使得两个领导人在同一个任期里同时被选举成功。（这是因为多个领导者可能会同时对集群的状态进行更改，从而导致数据不一致和系统错误）</p><p>不幸的是，<strong>任何服务器直接从旧的配置直接转换到新的配置的方案都是不安全的。一次性原子地转换所有服务器是不可能的，所以在转换期间整个集群存在划分成两个独立的大多数群体的可能性</strong>（见图 10）。</p><p><img src="https://github.com/maemual/raft-zh_cn/raw/master/images/raft-%E5%9B%BE10.png" alt="img"></p><p>图 10：直接从一种配置转到新的配置是十分不安全的，因为各个机器可能在任何的时候进行转换。</p><p>在这个例子中，集群配额从 3 台机器变成了 5 台。不幸的是，存在这样的一个时间点，两个不同的领导人在同一个任期里都可以被选举成功。一个是通过旧的配置，一个通过新的配置。</p><p>备注（这句话描述的是一个分布式系统中可能出现的领导选举问题。在一个分布式系统中，通常会有一个领导者选举机制来保证系统的一致性和协调性。领导者（或称为主节点）负责协调集群中的各个节点，确保系统正常运行。</p><p>当系统的配置发生变化时，例如集群的机器数量从3台增加到5台，这个变化可能需要一段时间才能在整个系统中生效。在这个过渡期间，可能会出现这样的情况：</p><ul><li>一部分系统仍然使用旧的配置，它们可能会选举出一个领导者。</li><li>另一部分系统（应该是新加入的系统）已经更新到新的配置，它们也可能会选举出另一个领导者。</li></ul><p>如果两个领导者分别在不同的节点集上被成功选举，并且它们的任期重叠，那么就存在两个有效的领导者。这种情况被称为“脑裂”（split-brain）问题，它可能导致数据不一致和服务中断，因为两个领导者都可能试图对系统进行操作。</p><p>为了避免这种情况，分布式系统通常需要有一种机制来处理配置变更时的过渡期，确保在任何时刻只有一个有效的领导者被选举出来。这可能涉及到使用锁服务、版本控制或其他一致性算法来同步配置变更和领导者选举过程）</p><p>为了确保系统的一致性和正确性，分布式系统通常会采用一种共识算法来进行领导者选举和日志复制。当新的节点加入集群时，共识算法会触发一次新的领导者选举，以确保所有节点都能够识别并跟随新的领导者。</p><p>为了保证安全性，配置更改必须使用两阶段方法。目前有很多种两阶段的实现。例如，有些系统在第一阶段停掉旧的配置所以集群就不能处理客户端请求；然后在第二阶段在<strong>启用新的配置</strong>。在 Raft 中，集群先切换到一个过渡的配置，我们称之为共同一致（<em>joint consensus</em>)；一旦共同一致已经被提交了，那么系统就切换到新的配置上。共同一致是老配置和新配置的结合：</p><ul><li>日志条目被复制给集群中新、老配置的所有服务器。</li><li>新、旧配置的服务器都可以成为领导人。</li><li>达成一致（针对选举和提交）需要分别在两种配置上获得大多数的支持。</li></ul><p>共同一致允许独立的服务器在不影响安全性的前提下，在不同的时间进行配置转换过程。此外，共同一致可以让集群在配置转换的过程中依然响应客户端的请求。</p><p>备注（</p><ol><li><strong>第一阶段</strong>：首先，系统会停止处理客户端请求，并关闭旧的配置。这一阶段的目的是确保在切换配置的过程中，系统处于一个已知的、稳定的状态。在这个状态下，系统不会接收或处理任何新的客户端命令。</li><li><strong>共同一致阶段</strong>：接下来，系统会启动一个过渡配置，即共同一致。在这个状态下，老配置和新配置共存，它们都被提交并生效。这个过渡状态允许系统在切换配置的过程中继续处理客户端请求。具体来说，系统会同时执行老配置和新配置中的操作，并确保它们的结果是一致的。例如，如果一个客户端命令在老配置中是有效的，那么在共同一致状态下，它仍然会被执行；同时，如果在新配置中这个命令是无效的，那么系统会拒绝执行该命令，并返回一个错误信息给客户端。</li><li><strong>第二阶段</strong>：一旦共同一致已经被提交了，系统就会切换到新的配置上。此时，老配置将被完全废弃，新配置成为系统的默认状态。在这个过程中，系统会继续处理客户端请求，并按照新配置的规则执行操作）</li></ol><p>集群配置在复制日志中以特殊的日志条目来存储和通信；图 11 展示了配置转换的过程。当一个领导人接收到一个改变配置从 C-old 到 C-new 的请求，他会为了共同一致存储配置（图中的 C-old,new），以前面描述的日志条目和副本的形式。一旦一个服务器将新的配置日志条目增加到它的日志中，他就会用这个配置来做出未来所有的决定（服务器总是使用最新的配置，无论他是否已经被提交）。这意味着领导人要使用 C-old,new 的规则来决定日志条目 C-old,new 什么时候需要被提交。如果领导人崩溃了，被选出来的新领导人可能是使用 C-old 配置也可能是 C-old,new 配置，这取决于赢得选举的候选人是否已经接收到了 C-old,new 配置。在任何情况下， C-new 配置在这一时期都不会单方面的做出决定。</p><p>备注（这段话描述的是分布式系统中配置转换的过程，特别是在使用Raft共识算法的系统中。当系统需要从一个旧的配置（C-old）切换到一个新的配置（C-new）时，会经历一个中间状态，即共同一致（joint consensus）状态，此时系统中同时存在旧配置和新配置的规则。</p><p>在这个过程中，领导人会接收到改变配置的请求，并将新的配置以日志条目和副本的形式存储起来。一旦一个服务器将新的配置日志条目加入到它的日志中，它就会开始使用这个新配置来做决定。这意味着即使新配置还没有被提交（即还没有被所有节点接受），服务器也会开始使用新配置的规则来处理请求。</p><p>如果在这个过渡期间领导人崩溃了，那么在新的领导人选举中，可能会选出使用旧配置（C-old）或共同一致配置（C-old,new）的领导人，这取决于哪个候选人赢得了选举。如果赢得选举的候选人已经接收到了共同一致配置，那么他会使用这个配置来做决定；否则，他会使用旧配置。</p><p>需要注意的是，在这个过渡期间，新配置（C-new）不会单独做出任何决定，直到它被成功提交并被所有节点接受。这是为了确保在配置转换的过程中，系统的一致性和稳定性不受影响）</p><p>一旦共同一致配置被提交，无论是旧配置（C-old）还是新配置（C-new），都不能单独做出决定，除非得到另一个配置的允许。这是因为在共同一致状态下，系统需要同时满足旧配置和新配置的规则，以确保在配置转换过程中的一致性和稳定性。</p><p>此外，<strong>领导人的完全特性保证了只有拥有共同一致配置日志条目的服务器才有可能被选举为领导人</strong>。这意味着在新的领导人选举中，只有已经接收到共同一致配置的服务器才有资格成为领导人。</p><p>当领导人创建一条关于新配置（C-new）的日志条目并复制给集群时，这是安全的，因为此时所有服务器都已经知道了新配置，并且会根据新配置的规则来处理请求。每个服务器在见到新的配置的时候就会立即生效，开始使用新配置的规则来处理请求。</p><p>当新配置在自身规则下被提交后，旧配置就变得无关紧要了。此时，不使用新配置的服务器可以被关闭，因为新配置已经被成功提交并被所有节点接受。</p><p>在整个过程中，旧配置和新配置没有任何机会同时做出单方面的决定，这保证了系统的安全性。</p><p><img src="https://github.com/maemual/raft-zh_cn/raw/master/images/raft-%E5%9B%BE11.png" alt="img"></p><p>图 11：一个配置切换的时间线。虚线表示已经被创建但是还没有被提交的配置日志条目，实线表示最后被提交的配置日志条目。</p><p>在分布式系统的上下文中，”配置条目在自己的日志中”通常指的是节点将配置变更记录为一条日志条目，并将其添加到自己的日志中。这里的”日志”是指节点用来持久化关键操作和事件的一系列记录。</p><p>在Raft共识算法中，当一个节点（领导人）需要更改系统的配置时，它会首先创建一个新的配置条目（在这个例子中是C-old,new），这个条目包含了旧配置和新配置的信息。然后，这个节点会将这个新的配置条目加入到自己的日志中，并尝试将其提交给集群中的其他节点。</p><p>提交的过程通常涉及到将配置条目复制到集群中的大多数节点。在这个过程中，每个收到新配置条目的节点也会将其加入到自己的日志中。一旦新配置条目被集群中的大多数节点接受并加入到它们的日志中，这个配置变更就可以被认为是已经被提交了。</p><p>在你的例子中，领导人首先创建了包含旧配置和新配置信息的C-old,new条目，并将其提交给旧配置的大多数节点和新配置的大多数节点。这意味着，领导人确保了在两个不同的配置下都有足够的节点支持这个变更。一旦C-old,new配置条目被提交，领导人就可以安全地创建并提交只包含新配置C-new的条目，因为此时已经没有节点还在使用旧配置C-old。</p><p>备注（配置通常包含了系统运行所需的各种参数和信息。对于Raft算法来说，配置可能会包含以下信息：</p><ol><li><strong>节点身份信息</strong>：如节点的标识符（Node ID），这在Raft中是唯一的，用于区分不同的节点。</li><li><strong>网络地址</strong>：包括节点的IP地址和端口号，这些信息用于节点间的通信。</li><li><strong>日志信息</strong>：Raft算法中每个节点维护一个日志，记录所有的操作和事件。配置可能会包含与日志相关的参数，比如日志的存储位置、日志保留策略等。</li><li><strong>状态机信息</strong>：Raft的状态机负责处理日志条目的应用，配置可能会包含状态机的初始状态或者相关参数。</li><li><strong>共识算法参数</strong>：如心跳超时时间（Heartbeat Timeout）、选举超时时间（Election Timeout）等，这些参数影响Raft算法的行为。</li><li><strong>集群元数据</strong>：可能包括集群的大小（节点数量）、当前的领导者信息、跟随者列表等。</li><li><strong>安全和认证信息</strong>：如TLS证书、密钥等，用于确保节点间通信的安全性。</li><li><strong>性能调优参数</strong>：比如并发处理的限制、网络传输的缓冲区大小等。</li><li><strong>故障恢复和备份策略</strong>：如何应对节点或网络故障的策略，以及数据备份的相关设置。</li><li><strong>系统和应用特定的配置</strong>：根据实际部署的分布式系统的具体需求，可能还会有其他与应用相关的配置项）</li></ol><p>在关于重新配置还有三个问题需要提出。</p><p>第一个问题是，新的服务器可能初始化没有存储任何的日志条目。当这些服务器以这种状态加入到集群中，那么他们需要一段时间来更新追赶，这时还不能提交新的日志条目。为了避免这种可用性的间隔时间，Raft 在配置更新之前使用了一种额外的阶段，在这个阶段，新的服务器以没有投票权身份加入到集群中来（领导人复制日志给他们，但是不考虑他们是大多数）。一旦新的服务器追赶上了集群中的其他机器，重新配置可以像上面描述的一样处理。</p><p>第二个问题是，<strong>集群的领导人可能不是新配置的一员</strong>。在这种情况下，领导人就会在提交了 C-new 日志之后退位（回到跟随者状态）。这意味着有这样的一段时间，领导人管理着集群，但是不包括他自己；他复制日志但是不把他自己算作是大多数之一。当 C-new 被提交时，会发生领导人过渡，因为这时是最早新的配置可以独立工作的时间点（将总是能够在 C-new 配置下选出新的领导人）。在此之前，可能只能从 C-old 中选出领导人。</p><p>备注（在分布式系统中，特别是在使用Raft算法的系统中，集群的配置变更是一个敏感的操作，它涉及到集群成员身份的改变。这里的关键点是，领导人可能不属于新配置（C-new）的一部分，即领导人可能是旧配置（C-old）中的一个节点。</p><p>在这种情况下，领导人负责将新配置的信息记录到日志中，并复制这些信息到集群中的其他节点。然而，由于领导人自己可能不属于新配置，它不能保证在新配置生效后仍然是集群的一部分。因此，领导人在新配置提交后需要退位，以确保新配置中的节点能够选出一个属于新配置的领导人。</p><p>这样做的原因是为了保证系统的一致性和稳定性。如果一个不属于新配置的节点继续担任领导人，那么它可能无法正确地代表新配置中的所有节点，这可能导致系统行为异常或不一致。此外，一旦新配置被提交，所有节点都应该按照新配置的规则来操作，包括领导人的选举）</p><p>第三个问题是，移除不在 C-new 中的服务器可能会扰乱集群。这些服务器将不会再接收到心跳，所以当选举超时，他们就会进行新的选举过程。他们会发送拥有新的任期号的请求投票 RPCs，这样会导致当前的领导人回退成跟随者状态。新的领导人最终会被选出来，但是被移除的服务器将会再次超时，然后这个过程会再次重复，导致整体可用性大幅降低。为了避免这个问题，<strong>当服务器确认当前领导人存在时，服务器会忽略请求投票 RPCs。确切地说，当服务器在当前最小选举超时时间内收到一个请求投票 RPC，他不会更新当前的任期号或者投出选票</strong>。这不会影响正常的选举，每个服务器在开始一次选举之前，至少等待一个最小选举超时时间。然而，这有利于避免被移除的服务器扰乱：如果领导人能够发送心跳给集群，那么他就不会被更大的任期号废黜。</p><h2 id="7-日志压缩"><a href="#7-日志压缩" class="headerlink" title="7 日志压缩"></a>7 日志压缩</h2><p>Raft 的日志在正常操作中不断地增长，但是在实际的系统中，日志不能无限制地增长。随着日志不断增长，他会占用越来越多的空间，花费越来越多的时间来重置。如果没有一定的机制去清除日志里积累的陈旧的信息，那么会带来可用性问题。快照技术被使用在 Chubby 和 ZooKeeper 中，接下来的章节会介绍 Raft 中的快照技术。</p><p>备注（这意味着，如果系统出现故障或需要恢复数据，可以从快照中恢复系统的状态，而不需要依赖之前的日志记录。因此，一旦快照完成，到那个时间点之前的日志就没有用处了，可以被丢弃）</p><p>除了快照这种压缩方法外，还有其他一些增量压缩的方法，例如日志清理和日志结构合并树。这些方法每次只对一小部分数据进行操作，从而分散了压缩的负载压力。</p><p>具体来说，这些方法首先选择一个已经积累的大量已经被删除或被覆盖对象的区域，然后重写那个区域还活跃的对象，之后释放那个区域。与简单操作整个数据集合的快照相比，这些方法需要增加复杂的机制来实现。状态机可以实现LSM tree使用和快照相同的接口，但是日志清除方法就需要修改Raft算法。</p><p><img src="https://github.com/maemual/raft-zh_cn/raw/master/images/raft-%E5%9B%BE12.png" alt="img"></p><p>图 12：一个服务器用新的快照替换了从 1 到 5 的条目，快照值存储了当前的状态。快照中包含了最后的索引位置和任期号。</p><p>图 12 展示了 Raft 中快照的基础思想。每个服务器独立地创建快照，只包括已经被提交的日志。主要的工作包括将状态机的状态写入到快照中。Raft 也包含一些少量的元数据到快照中：<strong>最后被包含索引</strong>指的是被快照取代的最后的条目在日志中的索引值（状态机最后应用的日志），<strong>最后被包含的任期</strong>指的是该条目的任期号。保留这些数据是为了支持快照后紧接着的第一个条目的附加日志请求时的一致性检查，因为这个条目需要前一日志条目的索引值和任期号。为了支持集群成员更新（第 6 节），快照中也将最后的一次配置作为最后一个条目存下来。一旦服务器完成一次快照，他就可以删除最后索引位置之前的所有日志和快照了，即使在系统故障或需要恢复数据的情况下，也可以通过快照快速恢复到最新的状态，而不需要回放大量的日志条目。</p><p>尽管通常服务器都是独立地创建快照，但是领导人必须偶尔的发送快照给一些落后的跟随者。这通常发生在当领导人已经丢弃了下一条需要发送给跟随者的日志条目的时候。幸运的是这种情况不是常规操作：一个与领导人保持同步的跟随者通常都会有这个条目。然而一个运行非常缓慢的跟随者或者新加入集群的服务器（第 6 节）将不会有这个条目。这时让这个跟随者更新到最新的状态的方式就是通过网络把快照发送给他们。</p><p><strong>安装快照 RPC</strong>：</p><p>由领导人调用以将快照的分块发送给跟随者。领导人总是按顺序发送分块。</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>领导人的任期号</td></tr><tr><td>leaderId</td><td>领导人的 ID，以便于跟随者重定向请求</td></tr><tr><td>lastIncludedIndex</td><td>快照中包含的最后日志条目的索引值</td></tr><tr><td>lastIncludedTerm</td><td>快照中包含的最后日志条目的任期号</td></tr><tr><td>offset</td><td>分块在快照中的字节偏移量</td></tr><tr><td>data[]</td><td>从偏移量开始的快照分块的原始字节</td></tr><tr><td>done</td><td>如果这是最后一个分块则为 true</td></tr></tbody></table><table><thead><tr><th>结果</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>当前任期号（currentTerm），便于领导人更新自己</td></tr></tbody></table><p><strong>备注（</strong></p><p>这些参数是Raft算法中发送快照分块时使用的一些关键信息，具体含义如下：</p><ul><li>term：领导人的任期号。在Raft算法中，任期是一个重要的概念，用于表示领导人的任期。当领导人发生变更时，任期号会增加。这个参数用于跟随者判断请求是否过期，如果跟随者的任期号大于或等于这个值，那么这个请求就被认为是过期的。</li><li>leaderId：领导人的ID。这个参数用于跟随者识别是哪个领导人发送的请求，同时也用于跟随者在需要时向领导人重定向请求。</li><li>lastIncludedIndex：快照中包含的最后日志条目的索引值。这个参数用于跟随者判断是否需要从领导人处获取更多的日志条目。</li><li>lastIncludedTerm：快照中包含的最后日志条目的任期号。这个参数与lastIncludedIndex一起使用。</li><li>offset：分块在快照中的字节偏移量。这个参数用于跟随者正确地将接收到的分块拼接成完整的快照。</li><li>data[]：从偏移量开始的快照分块的原始字节。这就是实际的快照数据，跟随者将这些数据写入磁盘完成快照的接收。</li><li>done：如果这是最后一个分块则为true。这个参数用于标识是否已经发送完所有的分块，跟随者根据这个参数判断是否需要继续等待更多的分块。</li></ul><p>当前任期号（currentTerm）是领导人在发送请求时自己的任期号，跟随者可以根据这个值来判断请求是否过期<strong>）</strong></p><p><strong>接收者实现</strong>：</p><ol><li>如果term &lt; currentTerm就立即回复</li><li>如果是第一个分块（offset 为 0）就创建一个新的快照</li><li>在指定偏移量写入数据</li><li>如果 done 是 false，则继续等待更多的数据</li><li>保存快照文件，丢弃具有较小索引的任何现有或部分快照</li><li>如果现存的日志条目与快照中最后包含的日志条目具有相同的索引值和任期号，则保留其后的日志条目并进行回复</li><li>丢弃整个日志</li><li>使用快照重置状态机（并加载快照的集群配置）</li></ol><p><img src="https://github.com/maemual/raft-zh_cn/raw/master/images/raft-%E5%9B%BE13.png" alt="img"></p><p>图 13：一个关于安装快照的简要概述。为了便于传输，快照都是被分成分块的；每个分块都给了跟随者生命的迹象，所以跟随者可以重置选举超时计时器。</p><p>在这种情况下领导人使用一种叫做安装快照的新的 RPC 来发送快照给太落后的跟随者；见图 13。当跟随者通过这种 RPC 接收到快照时，他必须自己决定对于已经存在的日志该如何处理。通常快照会包含没有在接收者日志中存在的信息。在这种情况下，跟随者丢弃其整个日志；它全部被快照取代，并且可能包含与快照冲突的未提交条目。如果接收到的快照是自己日志的前面部分（由于网络重传或者错误），那么被快照包含的条目将会被全部删除，但是快照后面的条目仍然有效，必须保留。</p><p>这种快照的方式背离了 Raft 的强领导人原则，因为跟随者可以在不知道领导人情况下创建快照。但是我们认为这种背离是值得的。领导人的存在，是为了解决在达成一致性的时候的冲突，但是在创建快照的时候，一致性已经达成，这时不存在冲突了，所以没有领导人也是可以的。数据依然是从领导人传给跟随者，只是跟随者可以重新组织他们的数据了。</p><p>我们考虑过一种替代的基于领导人的快照方案，即只有领导人创建快照，然后发送给所有的跟随者。但是这样做有两个缺点。第一，发送快照会浪费网络带宽并且延缓了快照处理的时间。每个跟随者都已经拥有了所有产生快照需要的信息，而且很显然，自己从本地的状态中创建快照比通过网络接收别人发来的要经济。第二，领导人的实现会更加复杂。例如，领导人需要发送快照的同时并行的将新的日志条目发送给跟随者，这样才不会阻塞新的客户端请求。</p><p>还有两个问题影响了快照的性能。首先，服务器必须决定什么时候应该创建快照。如果快照创建的过于频繁，那么就会浪费大量的磁盘带宽和其他资源；如果创建快照频率太低，他就要承受耗尽存储容量的风险，同时也增加了从日志重建的时间。一个简单的策略就是当日志大小达到一个固定大小的时候就创建一次快照。如果这个阈值设置的显著大于期望的快照的大小，那么快照对磁盘压力的影响就会很小了。</p><p>第二个影响性能的问题就是写入快照需要花费显著的一段时间，并且我们还不希望影响到正常操作。解决方案是通过写时复制的技术，这样新的更新就可以被接收而不影响到快照。例如，具有函数式数据结构的状态机天然支持这样的功能。另外，操作系统的写时复制技术的支持（如 Linux 上的 fork）可以被用来创建完整的状态机的内存快照（我们的实现就是这样的）。</p><h2 id="8-客户端交互"><a href="#8-客户端交互" class="headerlink" title="8 客户端交互"></a>8 客户端交互</h2><p>这一节将介绍客户端是如何和 Raft 进行交互的，包括客户端如何发现领导人和 Raft 是如何支持线性化语义的。这些问题对于所有基于一致性的系统都存在，并且 Raft 的解决方案和其他的也差不多。</p><p>Raft 中的客户端发送所有请求给领导人。当客户端启动的时候，他会随机挑选一个服务器进行通信。如果客户端第一次挑选的服务器不是领导人，那么那个服务器会拒绝客户端的请求并且提供他最近接收到的领导人的信息（附加条目请求包含了领导人的网络地址）。如果领导人已经崩溃了，那么客户端的请求就会超时；客户端之后会再次重试随机挑选服务器的过程。</p><p>我们 Raft 的目标是要实现线性化语义（每一次操作立即执行，只执行一次，在他调用和收到回复之间）。但是，如上述，Raft 是可能执行同一条命令多次的：例如，如果领导人在提交了这条日志之后，但是在响应客户端之前崩溃了，那么客户端会和新的领导人重试这条指令，导致这条命令就被再次执行了。解决方案就是客户端对于每一条指令都赋予一个唯一的序列号。然后，状态机跟踪每条指令最新的序列号和相应的响应。如果接收到一条指令，它的序列号已经被执行了，那么就立即返回结果，而不重新执行指令。</p><p>只读的操作可以直接处理而不需要记录日志。但是，在不增加任何限制的情况下，这么做可能会冒着返回脏数据的风险，因为响应客户端请求的领导人可能在他不知道的时候已经被新的领导人取代了。线性化的读操作必须不能返回脏数据，Raft 需要使用两个额外的措施在不使用日志的情况下保证这一点。首先，领导人必须有关于被提交日志的最新信息。领导人完全特性保证了领导人一定拥有所有已经被提交的日志条目，但是在他任期开始的时候，他可能不知道哪些是已经被提交的。为了知道这些信息，他需要在他的任期里提交一条日志条目。Raft 中通过领导人在任期开始的时候提交一个空白的没有任何操作的日志条目到日志中去来实现。第二，领导人在处理只读的请求之前必须检查自己是否已经被废黜了（他自己的信息已经变脏了如果一个更新的领导人被选举出来）。Raft 中通过让领导人在响应只读请求之前，先和集群中的大多数节点交换一次心跳信息来处理这个问题。可选的，领导人可以依赖心跳机制来实现一种租约的机制，但是这种方法依赖时间来保证安全性（假设时间误差是有界的）。</p><h2 id="9-读前心跳"><a href="#9-读前心跳" class="headerlink" title="9 读前心跳"></a>9 读前心跳</h2><p>当出现网络分区时，客户端读取子节点信息，领导者需要发送心跳给跟随者，若收到大部分回应，则表示读前心跳成功。此时跟随者会发送指令给领导者同步日志，并且则成功返回数据。</p><h2 id="10-续约令牌"><a href="#10-续约令牌" class="headerlink" title="10 续约令牌"></a>10 续约令牌</h2><ul><li>短租期刷新策略</li></ul><ol><li><ol><li>读前心跳</li><li>写入日志</li><li>选举成功</li></ol></li></ol><p>当出现以上情况时，刷新领导者的短租期时间，使得从节点再次请求领导者时候，能够直接同步日志，而不需要进行读前心跳。</p><p>延时选举任务开始了再收到心跳，这时候无法通过安全性校验，因为原来领导人的term比现在的term小</p>]]></content>
    
    
    <categories>
      
      <category>技术文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Raft相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>企业项目真实Spring Security+OAuth2+单点登录实现方案(源码可以联系)</title>
    <link href="/2024/05/19/%E4%BC%81%E4%B8%9A%E9%A1%B9%E7%9B%AE%E7%9C%9F%E5%AE%9ESpring%20Security+OAuth2+%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88(%E6%BA%90%E7%A0%81%E5%8F%AF%E4%BB%A5%E8%81%94%E7%B3%BB)/"/>
    <url>/2024/05/19/%E4%BC%81%E4%B8%9A%E9%A1%B9%E7%9B%AE%E7%9C%9F%E5%AE%9ESpring%20Security+OAuth2+%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88(%E6%BA%90%E7%A0%81%E5%8F%AF%E4%BB%A5%E8%81%94%E7%B3%BB)/</url>
    
    <content type="html"><![CDATA[<p>在当今数字化时代，企业对于信息安全和用户身份验证的重视与日俱增。为了满足这一需求，我们将带您深入探索Spring Security、OAuth2以及单点登录（SSO）技术的融合应用，打造一套高效、安全且用户体验友好的身份验证和授权体系。</p><h1 id="一、项目背景与意义"><a href="#一、项目背景与意义" class="headerlink" title="一、项目背景与意义"></a>一、项目背景与意义</h1><p>随着企业业务的不断扩展和云服务的普及，多系统、多应用的架构已成为常态。然而，这也带来了用户身份验证和权限管理的挑战。如何在保障信息安全的前提下，实现用户只需一次登录即可访问多个系统，成为亟待解决的问题。Spring Security+OAuth2+单点登录的解决方案应运而生，它将为您提供一个统一、灵活且强大的身份验证和授权框架。</p><h1 id="二、技术栈介绍"><a href="#二、技术栈介绍" class="headerlink" title="二、技术栈介绍"></a>二、技术栈介绍</h1><ol><li><strong>Spring Security</strong>：作为Spring框架中的安全模块，Spring Security提供了全面的身份验证和授权机制，支持多种认证方式和安全策略，确保系统安全无虞。</li><li><strong>OAuth2</strong>：OAuth2是一个开放标准，允许第三方应用获取用户授权，从而访问用户存储在服务提供商上的信息，而无需将用户名和密码提供给第三方应用。这种授权方式提高了用户数据的安全性，同时简化了开发者的工作。</li><li><strong>单点登录（SSO）</strong>：单点登录技术允许用户通过一次登录，访问多个相互信任的应用系统。这不仅提高了用户体验，还降低了企业的管理成本。</li></ol><h1 id="三、项目目标"><a href="#三、项目目标" class="headerlink" title="三、项目目标"></a>三、项目目标</h1><p>本项目旨在通过Spring Security、OAuth2和单点登录技术的整合，实现以下目标：</p><ol><li>提供统一的用户身份验证和授权服务，确保系统安全。</li><li>实现用户只需一次登录即可访问多个应用系统的功能，提高用户体验。</li><li>支持多种认证方式和安全策略，满足不同场景下的需求。</li><li>提供灵活的配置和管理界面，方便企业快速部署和维护。</li></ol><h1 id="四、预期成果"><a href="#四、预期成果" class="headerlink" title="四、预期成果"></a>四、预期成果</h1><p>通过本项目的实施，您将能够：</p><ol><li>深入了解Spring Security、OAuth2和单点登录技术的原理和应用。</li><li>掌握如何在企业实际应用中整合这些技术，实现高效、安全的身份验证和授权体系。</li><li>借鉴项目中的最佳实践和经验教训，为企业信息安全和用户体验提升提供参考。</li></ol><h1 id="五、详细内容"><a href="#五、详细内容" class="headerlink" title="五、详细内容"></a>五、详细内容</h1><h2 id="1、Security配置文件"><a href="#1、Security配置文件" class="headerlink" title="1、Security配置文件"></a>1、Security配置文件</h2><ol><li>PasswordEncoder：SpringSecurity为加密用户输入的账号提供的编码器，用户加密用户密码，和数据库密码进行对比</li><li>PermitResource：根域外部auth.yml配置不需要进行权限校验的URL，比如用户登陆、swagger等</li><li>SecurityFilterConfig：安全核心配置类，过滤用户访问的请求，检查是否存在该accessToken，如果存在，则向请求链中加入Authentication，后续http中如果没有检测到Authentication则通过SecurityAuthenticationEntryPoint，进行结果返回</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 加密配置</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PasswordConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title function_">passwordEncoder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> PasswordEncoderFactories.createDelegatingPasswordEncoder();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 允许访问的资源</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PermitResource</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指定被spring security忽略的URL</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getPermitList</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ResourcePatternResolver</span> <span class="hljs-variable">resolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathMatchingResourcePatternResolver</span>();<br>        Resource[] resources = resolver.getResources(<span class="hljs-string">&quot;classpath*:auth.yml&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;auth.ignore_urls&quot;</span>;<br>        <span class="hljs-comment">//访问文件配置的URL</span><br>        <span class="hljs-keyword">return</span> getPropertiesList(key, resources);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">getPropertiesList</span><span class="hljs-params">(String key, Resource... resources)</span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 解析资源文件</span><br>        <span class="hljs-keyword">for</span>(Resource resource : resources) &#123;<br>            <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> loadYamlProperties(resource);<br>            <span class="hljs-keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : properties.entrySet()) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">tmpKey</span> <span class="hljs-operator">=</span> StringUtils.substringBefore(entry.getKey().toString(), <span class="hljs-string">&quot;[&quot;</span>);<br>                <span class="hljs-keyword">if</span>(tmpKey.equalsIgnoreCase(key))&#123;<br>                    list.add(entry.getValue().toString());<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Properties <span class="hljs-title function_">loadYamlProperties</span><span class="hljs-params">(Resource... resources)</span> &#123;<br>        <span class="hljs-comment">//factory</span><br>        <span class="hljs-type">YamlPropertiesFactoryBean</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">YamlPropertiesFactoryBean</span>();<br>        factory.setResources(resources);<br>        factory.afterPropertiesSet();<br>        <span class="hljs-keyword">return</span> factory.getObject();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Spring SecurityFilter 配置文件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityFilterConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> OncePerRequestFilter authenticationTokenFilter;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PermitResource permitResource;<br><br>    <span class="hljs-meta">@Bean</span><br>    SecurityFilterChain <span class="hljs-title function_">filterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 忽略授权的地址列表</span><br>        List&lt;String&gt; permitList = permitResource.getPermitList();<br>        String[] <span class="hljs-keyword">permits</span> = permitList.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>]);<br>        http<br>                <span class="hljs-comment">// 设置每个请求必须走一次这个过滤</span><br>                .addFilterBefore(authenticationTokenFilter, UsernamePasswordAuthenticationFilter.class)<br>                <span class="hljs-comment">// 采用无状态的会话管理</span><br>                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)<br>                .and().authorizeRequests()<br>                <span class="hljs-comment">// 对指定的 URL 模式和 OPTIONS 请求开放访问</span><br>                .antMatchers(<span class="hljs-keyword">permits</span>).permitAll()<br>.antMatchers(HttpMethod.OPTIONS).permitAll()<br>                <span class="hljs-comment">// 要求对其他所有请求进行认证</span><br>                .anyRequest().authenticated()<br>                <span class="hljs-comment">// 配置自定义的异常处理</span><br>                .and().exceptionHandling().authenticationEntryPoint(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SecurityAuthenticationEntryPoint</span>())<br>                <span class="hljs-comment">// 允许网页在 iframe 中显示</span><br>                .and().headers().frameOptions().disable()<br>                <span class="hljs-comment">// 禁用CSRF保护</span><br>                .and().csrf().disable()<br>        ;<br>        <span class="hljs-keyword">return</span> http.build();<br>    &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 未授权异常</span><br><span class="hljs-comment"> * 匿名用户(token不存在、错误)，异常处理器</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityAuthenticationEntryPoint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AuthenticationEntryPoint</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commence</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>       response.setContentType(<span class="hljs-string">&quot;application/json; charset=utf-8&quot;</span>);<br>       response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br>       response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, HttpContextUtils.getOrigin());<br>       response.getWriter().print(JsonUtils.toJsonString(Result.error(ErrorCode.UNAUTHORIZED)));<br>    &#125;<br>&#125;<br>&#125;<br>---------------------------------------------------------------------------------------<br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthenticationTokenFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">OncePerRequestFilter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TokenStoreCache tokenStoreCache;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">accessToken</span> <span class="hljs-operator">=</span> TokenUtils.getAccessToken(request);<br>        <span class="hljs-comment">// accessToken为空，表示未登录</span><br>        <span class="hljs-keyword">if</span> (StringUtils.isBlank(accessToken)) &#123;<br>            chain.doFilter(request, response);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 获取登录用户信息</span><br>        <span class="hljs-type">UserDetail</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> tokenStoreCache.getUser(accessToken);<br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>            chain.doFilter(request, response);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 目的是将用户的认证信息设置到 Spring Security 的 SecurityContext 中</span><br>        <span class="hljs-comment">// 以便后续的请求处理过程中可以访问和使用该认证信息</span><br>        <span class="hljs-comment">// 用户存在</span><br>        <span class="hljs-type">Authentication</span> <span class="hljs-variable">authentication</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernamePasswordAuthenticationToken</span>(user, <span class="hljs-literal">null</span>, user.getAuthorities());<br><br>        <span class="hljs-comment">// 新建 SecurityContext</span><br>        <span class="hljs-type">SecurityContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SecurityContextHolder.createEmptyContext();<br>        context.setAuthentication(authentication);<br>        SecurityContextHolder.setContext(context);<br><br>        chain.doFilter(request, response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、账号密码登陆"><a href="#2、账号密码登陆" class="headerlink" title="2、账号密码登陆"></a>2、账号密码登陆</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/32410583/1715933627809-61e3efb5-c19d-4631-9566-ff55d05bcd53.jpeg" alt="img"></p><ol><li><p>根据SpringSecurity配置要求，需要实现核心类DaoAuthenticationProvider</p></li><li><ol><li>passwordEncoder： 传入密码编码器，用户将用户传入的密码编码后和数据库的密码进行对比</li><li>userDetailsService：根据用户名去查数据库，查询用户信息，返回结果需要为UserDetails类，和账号密码验证类型，在这里面配置权限，项目情况等过滤后的信息</li><li>然后框架内部重写了authenticate方法，只需要按照配置传入new UsernamePasswordAuthenticationToken(login.getUsername(), login.getPassword())，就能自动调用内部的方法进行账号密码对比和Authentication封装</li><li>在Controller中获取Authentication并拿出用户信息，以及对应的权限，按照access_token保存到Redis中，算是登陆成功</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfig</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserDetailsService userDetailsService;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SSOUserDetailsService ssoUserDetailsService;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MobileUserDetailsService mobileUserDetailsService;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MobileVerifyCodeService mobileVerifyCodeService;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PasswordEncoder passwordEncoder;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ApplicationEventPublisher applicationEventPublisher;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于对用户的身份进行认证</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    DaoAuthenticationProvider <span class="hljs-title function_">daoAuthenticationProvider</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">DaoAuthenticationProvider</span> <span class="hljs-variable">daoAuthenticationProvider</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DaoAuthenticationProvider</span>();<br>        <span class="hljs-comment">//用户密码通常不会以明文存储在数据库中，而是经过加密后存储</span><br>        daoAuthenticationProvider.setPasswordEncoder(passwordEncoder);<br>        <span class="hljs-comment">//需要配置一个 UserDetailsService 实现类，该类负责从数据库或其他数据源中获取用户的信息</span><br>        daoAuthenticationProvider.setUserDetailsService(userDetailsService);<br>        <span class="hljs-keyword">return</span> daoAuthenticationProvider;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 实现UserDetailsService接口，实现获取用户详情的方法</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDetailsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDetailsService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SysUserDetailsService sysUserDetailsService;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SysUserDao sysUserDao;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserDetails <span class="hljs-title function_">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException &#123;<br>        <span class="hljs-comment">//根据用户名查询用户</span><br>        <span class="hljs-type">SysUserEntity</span> <span class="hljs-variable">userEntity</span> <span class="hljs-operator">=</span> sysUserDao.getByUsername(username);<br>        <span class="hljs-keyword">if</span> (userEntity == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernameNotFoundException</span>(<span class="hljs-string">&quot;用户名或密码错误&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 获取用户详细信息</span><br>        <span class="hljs-keyword">return</span> sysUserDetailsService.getUserDetails(userEntity);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 封装UserDetail对象，查询数据权限范围、用户权限列表、项目权限列表</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title function_">getUserDetails</span><span class="hljs-params">(SysUserEntity userEntity)</span> &#123;<br>    <span class="hljs-comment">// 转换成UserDetail对象</span><br>    <span class="hljs-type">UserDetail</span> <span class="hljs-variable">userDetail</span> <span class="hljs-operator">=</span> SysUserConvert.INSTANCE.convertDetail(userEntity);<br><br>    <span class="hljs-comment">// 账号不可用</span><br>    <span class="hljs-keyword">if</span> (userEntity.getStatus() == UserStatusEnum.DISABLE.getValue()) &#123;<br>        userDetail.setEnabled(<span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 数据权限范围</span><br>    List&lt;Long&gt; dataScopeList = getDataScope(userDetail);<br>    userDetail.setDataScopeList(dataScopeList);<br><br>    <span class="hljs-comment">// 用户权限列表</span><br>    Set&lt;String&gt; authoritySet = sysMenuService.getUserAuthority(userDetail);<br>    userDetail.setAuthoritySet(authoritySet);<br><br>    <span class="hljs-comment">//项目权限列表</span><br>    List&lt;Long&gt; projectIds = sysUserService.getProjectIds(userDetail);<br>    userDetail.setProjectIds(projectIds);<br><br>    <span class="hljs-keyword">return</span> userDetail;<br>&#125;<br><br>----------------------------------------------------------------------------------------<br><span class="hljs-keyword">private</span> List&lt;Long&gt; <span class="hljs-title function_">getDataScope</span><span class="hljs-params">(UserDetail userDetail)</span> &#123;<br>    <span class="hljs-comment">// 获取角色数据权限范围</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">dataScope</span> <span class="hljs-operator">=</span> sysRoleDao.getDataScopeByUserId(userDetail.getId());<br>    userDetail.setDataScope(dataScope);<br>    <span class="hljs-keyword">if</span> (dataScope == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dataScope.equals(DataScopeEnum.ALL.getValue())) &#123;<br>        <span class="hljs-comment">// 全部数据权限，则返回null</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dataScope.equals(DataScopeEnum.DEPT_AND_CHILD.getValue())) &#123;<br>        <span class="hljs-comment">// 本部门及子部门数据</span><br>        List&lt;Long&gt; dataScopeList = sysOrgService.getSubOrgIdList(userDetail.getOrgId());<br>        <span class="hljs-comment">// 自定义数据权限范围</span><br>        dataScopeList.addAll(sysRoleDataScopeDao.getDataScopeList(userDetail.getId()));<br>        <span class="hljs-keyword">return</span> dataScopeList;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dataScope.equals(DataScopeEnum.DEPT_ONLY.getValue())) &#123;<br>        <span class="hljs-comment">// 本部门数据</span><br>        List&lt;Long&gt; dataScopeList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        dataScopeList.add(userDetail.getOrgId());<br>        <span class="hljs-comment">// 自定义数据权限范围</span><br>        dataScopeList.addAll(sysRoleDataScopeDao.getDataScopeList(userDetail.getId()));<br>        <span class="hljs-keyword">return</span> dataScopeList;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dataScope.equals(DataScopeEnum.CUSTOM.getValue())) &#123;<br>        <span class="hljs-comment">// 自定义数据权限范围</span><br>        <span class="hljs-keyword">return</span> sysRoleDataScopeDao.getDataScopeList(userDetail.getId());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> List&lt;Long&gt; <span class="hljs-title function_">getSubOrgIdList</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 所有机构的id、父级pid列表</span><br>    List&lt;SysOrgEntity&gt; orgList = baseMapper.getIdAndPidList();<br>    <span class="hljs-comment">// 递归查询所有子机构ID列表</span><br>    List&lt;Long&gt; subIdList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    getTree(id, orgList, subIdList);<br>    <span class="hljs-comment">// 本机构也添加进去</span><br>    subIdList.add(id);<br>    <span class="hljs-keyword">return</span> subIdList;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getTree</span><span class="hljs-params">(Long id, List&lt;SysOrgEntity&gt; orgList, List&lt;Long&gt; subIdList)</span> &#123;<br>    <span class="hljs-keyword">for</span> (SysOrgEntity org : orgList) &#123;<br>        <span class="hljs-keyword">if</span> (org.getPid().equals(id)) &#123;<br>            <span class="hljs-comment">// 递归将所有子节点的数据范围全拿到</span><br>            getTree(org.getId(), orgList, subIdList);<br>            subIdList.add(org.getId());<br>        &#125;<br>    &#125;<br>&#125;<br>----------------------------------------------------------------------------------------<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title function_">getUserAuthority</span><span class="hljs-params">(UserDetail user)</span> &#123;<br>    <span class="hljs-comment">// 系统管理员，拥有最高权限</span><br>    List&lt;String&gt; authorityList;<br>    <span class="hljs-keyword">if</span>(user.getSuperAdmin().equals(SuperAdminEnum.YES.getValue())) &#123;<br>        <span class="hljs-comment">//查询所有权限，sys:post:save，sys:post:update,sys:post:info等用户配置的全部权限</span><br>        authorityList = baseMapper.getAuthorityList();<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// 根据用户所在的角色，查询角色和菜单权限表，然后关联系统菜单表，得到改用户所有的权限</span><br>        authorityList = baseMapper.getUserAuthorityList(user.getId());<br>    &#125;<br><br>    <span class="hljs-comment">// 用户权限列表</span><br>    Set&lt;String&gt; permsSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(String authority : authorityList)&#123;<br>        <span class="hljs-comment">// 去掉空</span><br>        <span class="hljs-keyword">if</span>(StrUtil.isBlank(authority))&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        permsSet.addAll(Arrays.asList(authority.trim().split(<span class="hljs-string">&quot;,&quot;</span>)));<br>    &#125;<br>    <span class="hljs-keyword">return</span> permsSet;<br>&#125;<br>----------------------------------------------------------------------------------------<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> List&lt;Long&gt; <span class="hljs-title function_">getProjectIds</span><span class="hljs-params">(UserDetail userDetail)</span> &#123;<br>    <span class="hljs-keyword">if</span> (SuperAdminEnum.YES.getValue().equals(userDetail.getSuperAdmin())) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> baseMapper.getProjectIds(userDetail.getId());<br>&#125;<br><span class="hljs-meta">@PostMapping(&quot;login&quot;)</span><br><span class="hljs-meta">@Operation(summary = &quot;账号密码登录&quot;)</span><br><span class="hljs-keyword">public</span> Result&lt;SysTokenVO&gt; <span class="hljs-title function_">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> SysAccountLoginVO login)</span> &#123;<br>    <span class="hljs-type">SysTokenVO</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> sysAuthService.loginByAccount(login);<br>    <span class="hljs-keyword">return</span> Result.ok(token);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> SysTokenVO <span class="hljs-title function_">loginByAccount</span><span class="hljs-params">(SysAccountLoginVO login)</span> &#123;<br>    <span class="hljs-comment">// 验证码效验</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> sysCaptchaService.validate(login.getKey(), login.getCaptcha());<br>    <span class="hljs-keyword">if</span> (!flag) &#123;<br>        <span class="hljs-comment">// 保存登录日志</span><br>        sysLogLoginService.save(login.getUsername(), Constant.FAIL, LoginOperationEnum.CAPTCHA_FAIL.getValue());<br>        <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerException</span>(<span class="hljs-string">&quot;验证码错误&quot;</span>);<br>    &#125;<br><br>    Authentication authentication;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 用户认证，框架会自动调用loadUserByUsername方法，根据提供的编码器，将密码进行加密</span><br>        <span class="hljs-comment">// Spring Security的登录页面中，密码对比是自动进行的</span><br>        authentication = authenticationManager.authenticate(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernamePasswordAuthenticationToken</span>(login.getUsername(), login.getPassword()));<br>    &#125; <span class="hljs-keyword">catch</span> (BadCredentialsException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerException</span>(<span class="hljs-string">&quot;用户名或密码错误&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 用户信息</span><br>    <span class="hljs-type">UserDetail</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (UserDetail) authentication.getPrincipal();<br><br>    <span class="hljs-comment">//判断是否有项目id列表，没有，禁止登录</span><br>    <span class="hljs-keyword">if</span> (!SuperAdminEnum.YES.getValue().equals(user.getSuperAdmin()) &amp;&amp; CollectionUtils.isEmpty(user.getProjectIds())) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerException</span>(<span class="hljs-string">&quot;您没有项目租户空间可用，请联系管理员分配项目空间！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 生成 accessToken</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">accessToken</span> <span class="hljs-operator">=</span> TokenUtils.generator();<br><br>    <span class="hljs-comment">// 保存用户信息到缓存</span><br>    tokenStoreCache.saveUser(accessToken, user);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SysTokenVO</span>(accessToken);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、手机登陆"><a href="#3、手机登陆" class="headerlink" title="3、手机登陆"></a>3、手机登陆</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/32410583/1715930764417-6e4beb81-44b4-4e46-ae60-88ee583f579d.jpeg" alt="img"></p><ol><li><p>根据SpringSecurity配置要求，需要实现核心类MobileAuthenticationProvider</p></li><li><ol><li>该类需要实现AuthenticationProvider接口，重写authenticate，这是进行用户身份验证的核心逻辑，根据接口描述，验证成功则登陆成功</li><li>根据手机号去数据库，查询用户信息，返回结果需要为UserDetails类，和账号密码验证类型，在这里面配置权限，项目情况等过滤后的信息</li><li>然后对比该手机的验证码是否符合生成的验证码（验证码存储在Redis中，key为跟”message:sms:code” + mobile）</li><li>如果对比成功，则生成框架需要返回的Authentication</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 手机短信登录 AuthenticationProvider</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MobileAuthenticationProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AuthenticationProvider</span>, InitializingBean, MessageSourceAware &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">MessageSourceAccessor</span> <span class="hljs-variable">messages</span> <span class="hljs-operator">=</span> SpringSecurityMessageSource.getAccessor();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">GrantedAuthoritiesMapper</span> <span class="hljs-variable">authoritiesMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullAuthoritiesMapper</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MobileUserDetailsService mobileUserDetailsService;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MobileVerifyCodeService mobileVerifyCodeService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MobileAuthenticationProvider</span><span class="hljs-params">(MobileUserDetailsService mobileUserDetailsService, MobileVerifyCodeService mobileVerifyCodeService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.mobileUserDetailsService = mobileUserDetailsService;<br>        <span class="hljs-built_in">this</span>.mobileVerifyCodeService = mobileVerifyCodeService;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Authentication <span class="hljs-title function_">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException &#123;<br>        Assert.isInstanceOf(MobileAuthenticationToken.class, authentication,<br>                () -&gt; messages.getMessage(<br>                        <span class="hljs-string">&quot;MobileAuthenticationProvider.onlySupports&quot;</span>,<br>                        <span class="hljs-string">&quot;Only MobileAuthenticationProvider is supported&quot;</span>));<br>        <span class="hljs-type">MobileAuthenticationToken</span> <span class="hljs-variable">authenticationToken</span> <span class="hljs-operator">=</span> (MobileAuthenticationToken) authentication;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">mobile</span> <span class="hljs-operator">=</span> authenticationToken.getName();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> (String) authenticationToken.getCredentials();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">UserDetails</span> <span class="hljs-variable">userDetails</span> <span class="hljs-operator">=</span> mobileUserDetailsService.loadUserByMobile(mobile);<br>            <span class="hljs-keyword">if</span> (userDetails == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadCredentialsException</span>(<span class="hljs-string">&quot;Bad credentials&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">// 短信验证码效验</span><br>            <span class="hljs-keyword">if</span> (mobileVerifyCodeService.verifyCode(mobile, code)) &#123;<br>                <span class="hljs-keyword">return</span> createSuccessAuthentication(authentication, userDetails);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadCredentialsException</span>(<span class="hljs-string">&quot;mobile code is not matched&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (UsernameNotFoundException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadCredentialsException</span>(<span class="hljs-built_in">this</span>.messages<br>                    .getMessage(<span class="hljs-string">&quot;MobileAuthenticationProvider.badCredentials&quot;</span>, <span class="hljs-string">&quot;Bad credentials&quot;</span>));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> Authentication <span class="hljs-title function_">createSuccessAuthentication</span><span class="hljs-params">(Authentication authentication, UserDetails user)</span> &#123;<br>        <span class="hljs-type">MobileAuthenticationToken</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MobileAuthenticationToken</span>(user, <span class="hljs-literal">null</span>,<br>                authoritiesMapper.mapAuthorities(user.getAuthorities()));<br>        <span class="hljs-comment">// 用户可以通过该字段，配置一起其他希望传递的信息，比如IP等</span><br>        result.setDetails(authentication.getDetails());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">supports</span><span class="hljs-params">(Class&lt;?&gt; authentication)</span> &#123;<br>        <span class="hljs-comment">// 检查authentication所表示的类或接口是否是MobileAuthenticationToken类或其子类（或实现的接口</span><br>        <span class="hljs-keyword">return</span> MobileAuthenticationToken.class.isAssignableFrom(authentication);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Assert.notNull(mobileUserDetailsService, <span class="hljs-string">&quot;mobileUserDetailsService must not be null&quot;</span>);<br>        Assert.notNull(mobileVerifyCodeService, <span class="hljs-string">&quot;mobileVerifyCodeService must not be null&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMessageSource</span><span class="hljs-params">(MessageSource messageSource)</span> &#123;<br>        <span class="hljs-built_in">this</span>.messages = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageSourceAccessor</span>(messageSource);<br>    &#125;<br>&#125;<br>----------------------------------------------------------------------------------------<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result&lt;Boolean&gt; <span class="hljs-title function_">verifyCode</span><span class="hljs-params">(String mobile, String code)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> smsSendCache.getCode(mobile);<br>    <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 删除短信验证码</span><br>        smsSendCache.deleteCode(mobile);<br>        <span class="hljs-comment">// 效验</span><br>        flag = value.equalsIgnoreCase(code);<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok(flag);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>在上面authenticate方法验证通过后，需要配置Authentication类</p></li><li><ol><li>通过继承AbstractAuthenticationToken，重写getCredentials和getPrincipal相关方法</li><li>Object principal：证书设置为用户信息</li><li>String code：设置为null</li><li>Collection&lt;? extends GrantedAuthority&gt; authorities：该用户对应角色所拥有的接口权限</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 手机短信登录 AuthenticationToken</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MobileAuthenticationToken</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAuthenticationToken</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> SpringSecurityCoreVersion.SERIAL_VERSION_UID;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object principal;<br>    <span class="hljs-keyword">private</span> String code;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MobileAuthenticationToken</span><span class="hljs-params">(Object principal, String code)</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-literal">null</span>);<br>        <span class="hljs-built_in">this</span>.principal = principal;<br>        <span class="hljs-built_in">this</span>.code = code;<br>        setAuthenticated(<span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MobileAuthenticationToken</span><span class="hljs-params">(Object principal, String code, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> &#123;<br>        <span class="hljs-built_in">super</span>(authorities);<br>        <span class="hljs-built_in">this</span>.principal = principal;<br>        <span class="hljs-built_in">this</span>.code = code;<br>        <span class="hljs-built_in">super</span>.setAuthenticated(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAuthenticated</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isAuthenticated)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException &#123;<br>        Assert.isTrue(!isAuthenticated,<br>                <span class="hljs-string">&quot;Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead&quot;</span>);<br>        <span class="hljs-built_in">super</span>.setAuthenticated(<span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getCredentials</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.code;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getPrincipal</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.principal;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eraseCredentials</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.eraseCredentials();<br>        <span class="hljs-built_in">this</span>.code = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>用户认证通过后，会返回携带这用户信息的Authentication，在Controller层，将用户信息提取出来，并且设置accessToken与用户信息的对应，存到redis中，完成登陆逻辑，将token返回给前端展示</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;mobile&quot;)</span><br><span class="hljs-meta">@Operation(summary = &quot;手机号登录&quot;)</span><br><span class="hljs-keyword">public</span> Result&lt;SysTokenVO&gt; <span class="hljs-title function_">mobile</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> SysMobileLoginVO login)</span> &#123;<br>    <span class="hljs-type">SysTokenVO</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> sysAuthService.loginByMobile(login);<br>    <span class="hljs-keyword">return</span> Result.ok(token);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> SysTokenVO <span class="hljs-title function_">loginByMobile</span><span class="hljs-params">(SysMobileLoginVO login)</span> &#123;<br>    Authentication authentication;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 用户认证</span><br>        authentication = authenticationManager.authenticate(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">MobileAuthenticationToken</span>(login.getMobile(), login.getCode()));<br>    &#125; <span class="hljs-keyword">catch</span> (BadCredentialsException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerException</span>(<span class="hljs-string">&quot;手机号或验证码错误&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 用户信息</span><br>    <span class="hljs-type">UserDetail</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (UserDetail) authentication.getPrincipal();<br>    <span class="hljs-comment">// 生成 accessToken</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">accessToken</span> <span class="hljs-operator">=</span> TokenUtils.generator();<br>    <span class="hljs-comment">// 保存用户信息到缓存</span><br>    tokenStoreCache.saveUser(accessToken, user);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SysTokenVO</span>(accessToken);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、单点登陆SSO"><a href="#4、单点登陆SSO" class="headerlink" title="4、单点登陆SSO"></a>4、单点登陆SSO</h2><ol><li>单点登陆方案总体和上面类似</li><li>唯一区别点，在于new SSOAuthenticationToken(codeKey, ssoUrl)，这里是中心登陆过来传递的token和鉴权中心的网络地址</li><li>登陆时，给中心鉴权端发起请求，携带codeKey和标识该系统的key，然后中心端根据codeKey，得到中心端的用户名，并且根据数据库的用户映射关系，比如中心端用户C_Wang对应第三方系统的Admin。则返回中心用户对应的该系统的用户Admin</li><li>根据返回的用户信息Admin，去完善第三方用户的其他信息。最后在authenticate方法中，如果userDetails不为空，则是登陆成功！</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> SysTokenVO <span class="hljs-title function_">loginByCodeKey</span><span class="hljs-params">(String codeKey)</span> &#123;<br>    Authentication authentication;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 用户认证</span><br>        authentication = authenticationManager.authenticate(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">SSOAuthenticationToken</span>(codeKey, ssoUrl));<br>    &#125; <span class="hljs-keyword">catch</span> (BadCredentialsException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerException</span>(<span class="hljs-string">&quot;手机号或验证码错误&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 用户信息</span><br>    <span class="hljs-type">UserDetail</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (UserDetail) authentication.getPrincipal();<br><br>    <span class="hljs-comment">// 生成 accessToken</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">accessToken</span> <span class="hljs-operator">=</span> TokenUtils.generator();<br><br>    <span class="hljs-comment">// 保存用户信息到缓存</span><br>    tokenStoreCache.saveUser(accessToken, user);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SysTokenVO</span>(accessToken);<br>&#125;<br><br>---------------------------------------------------------------------------------------<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 第三方token登录 AuthenticationProvider</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SSOAuthenticationProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AuthenticationProvider</span>, InitializingBean, MessageSourceAware &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">MessageSourceAccessor</span> <span class="hljs-variable">messages</span> <span class="hljs-operator">=</span> SpringSecurityMessageSource.getAccessor();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">GrantedAuthoritiesMapper</span> <span class="hljs-variable">authoritiesMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullAuthoritiesMapper</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SSOUserDetailsService ssoUserDetailsService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SSOAuthenticationProvider</span><span class="hljs-params">(SSOUserDetailsService ssoUserDetailsService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.ssoUserDetailsService = ssoUserDetailsService;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Authentication <span class="hljs-title function_">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException &#123;<br>        Assert.isInstanceOf(SSOAuthenticationToken.class, authentication,<br>                () -&gt; messages.getMessage(<br>                        <span class="hljs-string">&quot;SSOAuthenticationProvider.onlySupports&quot;</span>,<br>                        <span class="hljs-string">&quot;Only SSOAuthenticationProvider is supported&quot;</span>));<br>        <span class="hljs-type">SSOAuthenticationToken</span> <span class="hljs-variable">authenticationToken</span> <span class="hljs-operator">=</span> (SSOAuthenticationToken) authentication;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">codeKey</span> <span class="hljs-operator">=</span> authenticationToken.getName();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> (String) authenticationToken.getCredentials();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">UserDetails</span> <span class="hljs-variable">userDetails</span> <span class="hljs-operator">=</span> ssoUserDetailsService.loadUserByCodeKey(codeKey, url);<br>            <span class="hljs-keyword">if</span> (userDetails == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadCredentialsException</span>(<span class="hljs-string">&quot;Bad credentials&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> createSuccessAuthentication(authentication, userDetails);<br>        &#125; <span class="hljs-keyword">catch</span> (UsernameNotFoundException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadCredentialsException</span>(<span class="hljs-built_in">this</span>.messages<br>                    .getMessage(<span class="hljs-string">&quot;SSOAuthenticationProvider.badCredentials&quot;</span>, <span class="hljs-string">&quot;Bad credentials&quot;</span>));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> Authentication <span class="hljs-title function_">createSuccessAuthentication</span><span class="hljs-params">(Authentication authentication, UserDetails user)</span> &#123;<br>        <span class="hljs-type">SSOAuthenticationToken</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SSOAuthenticationToken</span>(user, <span class="hljs-literal">null</span>,<br>                authoritiesMapper.mapAuthorities(user.getAuthorities()));<br>        result.setDetails(authentication.getDetails());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">supports</span><span class="hljs-params">(Class&lt;?&gt; authentication)</span> &#123;<br>        <span class="hljs-keyword">return</span> SSOAuthenticationToken.class.isAssignableFrom(authentication);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Assert.notNull(ssoUserDetailsService, <span class="hljs-string">&quot;ssoUserDetailsService must not be null&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMessageSource</span><span class="hljs-params">(MessageSource messageSource)</span> &#123;<br>        <span class="hljs-built_in">this</span>.messages = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageSourceAccessor</span>(messageSource);<br>    &#125;<br><br>&#125;<br>---------------------------------------------------------------------------------------<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 第三方token登录 AuthenticationProvider</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SSOAuthenticationToken</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAuthenticationToken</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> SpringSecurityCoreVersion.SERIAL_VERSION_UID;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object principal;<br>    <span class="hljs-keyword">private</span> String url;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SSOAuthenticationToken</span><span class="hljs-params">(Object principal, String url)</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-literal">null</span>);<br>        <span class="hljs-built_in">this</span>.principal = principal;<br>        <span class="hljs-built_in">this</span>.url = url;<br>        setAuthenticated(<span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SSOAuthenticationToken</span><span class="hljs-params">(Object principal, String url, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> &#123;<br>        <span class="hljs-built_in">super</span>(authorities);<br>        <span class="hljs-built_in">this</span>.principal = principal;<br>        <span class="hljs-built_in">this</span>.url = url;<br>        <span class="hljs-built_in">super</span>.setAuthenticated(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAuthenticated</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isAuthenticated)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException &#123;<br>        Assert.isTrue(!isAuthenticated,<br>                <span class="hljs-string">&quot;Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead&quot;</span>);<br>        <span class="hljs-built_in">super</span>.setAuthenticated(<span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getCredentials</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.url;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getPrincipal</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.principal;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eraseCredentials</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.eraseCredentials();<br>        <span class="hljs-built_in">this</span>.url = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br>---------------------------------------------------------------------------------------<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于第三方token的用户身份验证</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Bean</span><br>SSOAuthenticationProvider <span class="hljs-title function_">ssoAuthenticationProvider</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//数据源: 从第三方获取用户名，从自己库获取用户信息</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SSOAuthenticationProvider</span>(ssoUserDetailsService);<br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SSOUserDetailsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SSOUserDetailsService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SysUserDetailsService sysUserDetailsService;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SysUserDao sysUserDao;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserDetails <span class="hljs-title function_">loadUserByCodeKey</span><span class="hljs-params">(String codeKey, String url)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException &#123;<br>        <span class="hljs-comment">//根据token 调用第三方查询 用户名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">userName</span> <span class="hljs-operator">=</span> getSSOUserName(codeKey, url);<br><br>        <span class="hljs-type">SysUserEntity</span> <span class="hljs-variable">userEntity</span> <span class="hljs-operator">=</span> sysUserDao.getByUsername(userName);<br>        <span class="hljs-keyword">if</span> (userEntity == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernameNotFoundException</span>(<span class="hljs-string">&quot;用户名或密码错误&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sysUserDetailsService.getUserDetails(userEntity);<br>    &#125;<br><br>    <span class="hljs-comment">// 调用远程地址，进行中心鉴权处理，如果查到对应用户名，则访问成功</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getSSOUserName</span><span class="hljs-params">(String codeKey, String url)</span> &#123;<br>        Map&lt;String, Object&gt; params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();<br>        <span class="hljs-comment">// 对方区分外部系统的标识</span><br>        params.put(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-string">&quot;xxx&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">requestStr</span> <span class="hljs-operator">=</span> HttpRequest.post(url)<br>                .auth(<span class="hljs-string">&quot;Bearer &quot;</span> + codeKey)<br>                .body(JSONUtil.toJsonStr(params))<br>                .execute()<br>                .body();<br>        <span class="hljs-type">JSON</span> <span class="hljs-variable">parse</span> <span class="hljs-operator">=</span> JSONUtil.parse(requestStr);<br>        <span class="hljs-keyword">return</span> parse.getByPath(<span class="hljs-string">&quot;data&quot;</span>, String.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h1><p>信息安全是企业发展的基石，而用户身份验证和授权则是信息安全的核心。让我们一起走进Spring Security+OAuth2+单点登录的世界，共同探索企业信息安全的新境界！</p>]]></content>
    
    
    <categories>
      
      <category>技术文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Security</tag>
      
      <tag>OAuth2</tag>
      
      <tag>单点登录实现方案</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
